<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://tars-c.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tars-c.github.io/" rel="alternate" type="text/html" /><updated>2020-05-09T01:13:25+09:00</updated><id>https://tars-c.github.io/feed.xml</id><title type="html">타스의 개발 블로그</title><author><name>타스 (TARS-C)</name></author><entry><title type="html">[MFC][실습] Document CArchive 기본타입 클래스 직렬화</title><link href="https://tars-c.github.io/explict-serialize-2020/05/09" rel="alternate" type="text/html" title="[MFC][실습] Document CArchive 기본타입 클래스 직렬화" /><published>2020-05-07T00:00:00+09:00</published><updated>2020-05-09T00:00:00+09:00</updated><id>https://tars-c.github.io/explict-serialize-2020/05/Document%20CAcrchive%20%EA%B8%B0%EB%B3%B8%ED%83%80%EC%9E%85%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EC%A7%81%EB%A0%AC%ED%99%94</id><content type="html" xml:base="https://tars-c.github.io/explict-serialize-2020/05/09">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;실습은 Doc 클래스 가상함수인 Serialize() 및 MyData 클래스 구현부만 개발한다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;데이터를 직렬화 하기 위해서는 CObject 클래스를 상속받거나&lt;br /&gt;
또는 CObject를 상속받은 자식 및 자손 클래스를 상속받으면 된다. (예: CBitmap, CButton 등)&lt;br /&gt;
(COjbect 클래스를 상속받는 이유는 Serialize() 가상함수 재정의를 위해서이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MFC에서 직렬화를 하는 방법이 대표적으로 2가지가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;툴바에서 Open, Save 버튼을 이용한 방법 (CArchive 암시적 생성)&lt;/li&gt;
      &lt;li&gt;CFile, CArchive 객체를 이용한 방법 (CArchive 명시적 생성)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;겉으로 보면 달라 보이지만 둘다 비슷하다고 생각하면 된다.&lt;/p&gt;

&lt;p&gt;CArchive를 암시적으로 생성하는 원리는 간단하다.&lt;br /&gt;
사용자가 다른 이름으로 저장 또는 저장을 누르면 사용자가 선택한 파일을에 대해&lt;br /&gt;
내부적으로 CFile객체를 만들고 CArchive 객체는 파일을 참조하여 만들어진다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;도큐먼트(Doc)에서 Serialize() 함수를 호출하여 CArchive 객체에 전달한다.&lt;br /&gt;
직렬화 할 때 CArchive 객체에 데이터를 전달하고 버퍼가 가득찬 경우 파일 Write를 시작한다.&lt;br /&gt;
원시 타입이 아닌 Object 타입인 경우 따로 직렬화를 구현하여 Serialize() 함수를 호출한다.&lt;/p&gt;

&lt;h2 id=&quot;객체의-직렬화-매크로-함수&quot;&gt;객체의 직렬화: 매크로 함수&lt;/h2&gt;
&lt;p&gt;매크로 함수는 2가지다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DECLARE_SERIAL(Class)
    &lt;ul&gt;
      &lt;li&gt;매크로 함수는 직려화할 클래스 헤더(*.h)에 적는다.&lt;/li&gt;
      &lt;li&gt;클래스 정보를 요구한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IMPLMENT_SERIAL(Class, BaseClass, )
    &lt;ul&gt;
      &lt;li&gt;직렬화를 구현할 클래스(Serialize 함수가 재정의된) 구현부(*.cpp)에 적는다.&lt;/li&gt;
      &lt;li&gt;클래스 정보를 요구한다.&lt;/li&gt;
      &lt;li&gt;데이터 검증을 위한 스키마 넘버를 요구한다. (0의 수 이상 사용)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;매크로 함수는 직렬화 클래스를 명시할 뿐 사용하지 않는다고해서 직렬화가 불가능하다는 의미는 아니다.&lt;br /&gt;
개발 프로젝트가 커지면서 외부 컴퓨터 및 시스템을 사용할 때 데이터를 가져오거나 교환 시&lt;br /&gt;
스키마 넘버는 직렬화 데이터가 클래스에 해당하는 데이터가 일치하는지 검증을 하기 위해 사용된다.&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;SQL 데이터베이스 스키마 넘버와 혼동하지말자&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;객체의-직렬화-사용할-함수&quot;&gt;객체의 직렬화: 사용할 함수&lt;/h2&gt;
&lt;p&gt;CObject* 타입의 데이터 및 원시타입(Primitive)의 데이터만 «, » 연산자를 사용하도록 한다.&lt;br /&gt;
사용자 정의 타입의 객체 데이터를 저장하고 불러올 때에는 Write(), Read() 함수를 사용한다.&lt;br /&gt;
MBCS 및 유니코드 환경의 문자열을 저장 및 불러올 땐 WriteString(), ReadString() 함수를 사용한다.&lt;/p&gt;

&lt;h2 id=&quot;객체의-직렬화-실습&quot;&gt;객체의 직렬화: 실습&lt;/h2&gt;

&lt;h3 id=&quot;헤더-및-구현-코드&quot;&gt;헤더 및 구현 코드&lt;/h3&gt;

&lt;figcaption&gt;MyClass.h&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CObject&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DECLARE_SERIAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ABCDEFG&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;COLORREF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CArchive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 기타 코드 생략&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figcaption&gt;MyClass.cpp&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;IMPLEMENT_SERIAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RGB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CArchive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsStoring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// storing code&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;// loading code&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_num2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 기타코드 생략&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figcaption&gt;CNormalSerializeDoc.h&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;MyData.h&quot;
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CNormalSerializeDoc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CDocument&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MyData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 기타코드 생략&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figcaption&gt;CNormalSerializeDoc.cpp&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CNormalSerializeDoc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CArchive&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsStoring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// TODO: 여기에 저장 코드를 추가합니다.&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// TODO: 여기에 로딩 코드를 추가합니다.&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;UpdateAllViews&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;설명-및-결과&quot;&gt;설명 및 결과&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;위에 선언된 변수값
    &lt;ul&gt;
      &lt;li&gt;직렬화 스키마 번호: 9&lt;/li&gt;
      &lt;li&gt;m_num1: -1 -&amp;gt; 3&lt;/li&gt;
      &lt;li&gt;m_num2: -1 -&amp;gt; 7&lt;/li&gt;
      &lt;li&gt;m_dnum1: 0.0 -&amp;gt; 3.0&lt;/li&gt;
      &lt;li&gt;text[10]: “abcdefghijk”&lt;/li&gt;
      &lt;li&gt;color: RGB(255, 255, 15)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;m_data 에서 원시타입으로 접근하여 하나씩 직렬화한 것이다. 너무 쉽고 간단하다.&lt;br /&gt;
도큐먼트 Serialize() 함수에서는 간단히 해당 객체가 가진 시리얼라이즈 함수를 호출한다.&lt;br /&gt;
핵심은 해당 오브젝트의 Serialize() 함수를 재정의하여 구현한다.&lt;br /&gt;
주의할 점은 부모 클래스의 CObject::Serialize() 함수를 먼저 호출해주는 것이다.&lt;br /&gt;
불러오기를 테스트할 땐 값을 확인하기 위해 기본값을 임시로 바꾼다.&lt;br /&gt;
저장 및 불러오기를 테스트하자!&lt;br /&gt;
&lt;img src=&quot;/assets/images/Serialize/messagebox.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직렬화를 마치면 22Byte 크기를 가진 파일이 생긴다.&lt;br /&gt;
자세한건 아래 그림을 참고하자 &lt;strong&gt;&lt;del&gt;만들기 진짜 힘들었다&lt;/del&gt;&lt;/strong&gt;
데이터가 저장된 파일의 크기는 직렬화된 멤버변수 타입의 크기가 모두 더해져서 만들어진다.&lt;br /&gt;
Hex Viewer로 파일을 살펴보면 저장한 데이터들이 16진수로 저장되어 들어가져있다.&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;16진수는 컴퓨터 공부를 하면 할 수록 반드시 알아야할 녀석이라는 걸 깨닫게 된다.)&lt;/del&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;/assets/images/Serialize/hex_viewer.png&quot; alt=&quot;img2&quot; /&gt;&lt;br /&gt;
값이 잘 불러와진다. OK!&lt;/p&gt;

&lt;h2 id=&quot;확장명-필터-저장-및-불러오기&quot;&gt;확장명 필터 (저장 및 불러오기)&lt;/h2&gt;
&lt;p&gt;특정 확장명을 가진 파일에 대해서 저장 및 불러오기에 대해 알아보자&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CArchive 객체는 CFile 객체를 참조하고 있다.&lt;br /&gt;
사용자가 *.dat 확장명을 가진 파일에 대해서만 직렬화를 이용한 저장 및 불러오기를 진행하려고 한다.&lt;br /&gt;
툴바에서 사용되는 파일 다이얼로그 인스턴스에 접근하는 방법을 모르기에&lt;br /&gt;
CFile객체로 접근하여 파일의 패스 정보를 이용해 파일을 필터링한다.&lt;/p&gt;
&lt;figcaption&gt;CNormalSerializeDoc.cpp - Serialize()&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;CFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pFile&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pFile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetFilePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dotIdx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReverseFind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dotIdx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;extension_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetLength&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dotIdx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CString&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fileExtensionStr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extension_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;AfxGetMainWnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MessageBox&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileExtensionStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileExtensionStr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Serialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;글 다썻다아 ~&lt;/strong&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="툴바" /><category term="Toolbar" /><category term="bitmap" /><category term="직렬화" /><category term="serialize" /><category term="serialization" /><category term="CArchive" /><summary type="html">[MFC][실습] Document CAcrchive 기본타입 클래스 직렬화</summary></entry><entry><title type="html">[MacOS] 뒤늦은 모하비(Mojave) 10.13.6 업데이트 (이미지)</title><link href="https://tars-c.github.io/mojave-update/2020/05/07" rel="alternate" type="text/html" title="[MacOS] 뒤늦은 모하비(Mojave) 10.13.6 업데이트 (이미지)" /><published>2020-05-07T00:00:00+09:00</published><updated>2020-05-07T00:00:00+09:00</updated><id>https://tars-c.github.io/mojave-update/2020/05/MacOS-Mojave%20Update</id><content type="html" xml:base="https://tars-c.github.io/mojave-update/2020/05/07">&lt;p&gt;정말 &lt;strong&gt;다크모드&lt;/strong&gt;가 눈에 좋을까 ?&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-_0vKgI5dcbM/XrTRzuKPRbI/AAAAAAAAAsE/QKZkP9w1OZgs2-OjrRYq15PZU2CWpQ7WACLcBGAsYHQ/s1600/mojave1.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;왜-갑자기-mojave로-업뎃을-했는가-&quot;&gt;왜 갑자기 Mojave로 업뎃을 했는가 ?&lt;/h2&gt;
&lt;p&gt;요즘들어 공부를 오래하다보니…&lt;br /&gt;
눈 상태가 조금 안좋아졌다.&lt;/p&gt;

&lt;p&gt;나는 과거에 다크모드 광이었는데&lt;br /&gt;
어느날부터 자동 밝기라는 기능을 사용하면서 다크모드는 눈에 안좋다고 착각했다. &lt;del&gt;(착각이 맞겠지?)&lt;/del&gt;&lt;br /&gt;
그리고 자동 밝기를 적용하면서 화이트톤 배경으로 모두 바꾸고 사용했다.&lt;/p&gt;

&lt;p&gt;아직도 의문점이 든다. 다크모드가 눈 건강에 정말 좋은지…&lt;br /&gt;
인터넷에 찾아보면 하얀색은 빛을 반사하기 때문에 눈에 안좋다고 한다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(눈에 가장 좋은 그린 모드는 없나 ?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;운영체제를 넘어 크롬이나 사파리 같은 것도 다크모드 기능을 지원하는거 보면&lt;br /&gt;
분명 효과는 있을거라 생각한다.&lt;br /&gt;
그래서 High Sierra 파이널 버전에서 Mojave로 업데이트하려고 한다.&lt;/p&gt;

&lt;p&gt;나는 프로그램 업데이트를 선호하지 않는다.&lt;br /&gt;
업데이트할 수록 기능이 빨라지면서 개선되기도 하지만 반대로 확장되는 기능은 많아진다.&lt;br /&gt;
그만큼 나의 맥 배터리를 갉아먹기도하고&lt;br /&gt;
기능이 확장된 만큼 백그라운드 프로세스가 늘어나는건 기정사실인거 같다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(꼭 메모리 크기가 적은 백그라운드 프로세스는 계속 돌더라)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;직접 경험한 바로 윈도우즈10 애니버서리 업데이트를(Build: 1900)하면서&lt;br /&gt;
말도안되는 기능들이 갑자기 늘어난 것을 직접 보았다. &lt;del&gt;&lt;strong&gt;(서비스를 일일히 꺼서 최적화시켰다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;특히 마소나 애플을 보면 PC와 모바일 그리고 스마트홈 기기와 연동시키는 작업을 많이한다.&lt;br /&gt;
그런 기능 사용도 안하면 아예 비활성화 기능을 만들어줬으면 싶다.&lt;br /&gt;
눈 상태도 안좋고 가끔 다크모드도 써봐야하니까 업데이트를 다짐했다.&lt;/p&gt;

&lt;h2 id=&quot;mojave-업데이트&quot;&gt;Mojave 업데이트&lt;/h2&gt;
&lt;p&gt;모든 프로그램이 그렇지만 호환성이 떨어지는 프로그램을 쓰는건 아니라고 생각한다.&lt;br /&gt;
나는 시간이 지나 기능이 호환되고 안정한 상태가 되야 그 프로그램을 다운받고 사용한다.&lt;br /&gt;
베타 버전은 과거에 너무나 많이 겪어서 이젠 겪고싶디 않다.&lt;/p&gt;

&lt;p&gt;기업들이 최신버전을 팔기 위한 전략인지.. 앱스토어를 보면 베타버전처럼 느껴지는 카탈리나가 존재한다.&lt;br /&gt;
특별한 기능을 사용할 경우가 생기지 않는한 절대 카탈리나는 사용하지 않을 것이다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(애플님 Mojave도 충분히 좋습니다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;인터넷에 찾다보니 특정 링크로 들어가면 Mojave로 다운받을 수 있다고 한다.&lt;br /&gt;
특이하게 아래 링크로 들어가면 카탈리나가 아닌 Mojave를 다운받을 수 있다.&lt;br /&gt;
&lt;a href=&quot;https://apps.apple.com/kr/app/macos-mojave/id1398502828?mt=12&quot; target=&quot;_blank&quot;&gt;숨겨진 Mojave 다운로드가 가능한 앱스토어 열기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;링크를 누르는 순간 마치 해리포터 킹스크로스역 9와 4분의 3정거장에 들어온 느낌이다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Fun/kings.jpeg&quot; alt=&quot;kings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
본격적으로 설치해보자!&lt;br /&gt;
MacOS 모하비(Mojave) 크기는 약 6GB이다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(윈도우즈10이랑 비교할 때 생각보다 큰 느낌인데 ?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-r8ABBoz3x2Q/XrTR1dXzE8I/AAAAAAAAAsQ/VxWk4DC_8kQqVms-bRQABgHchffhdNCGQCLcBGAsYHQ/s1600/mojave2.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;macOS Mojave  간편함, 강력함 그져 경이로울뿐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;정말 애플답게 멘트를 잘친다. &lt;del&gt;&lt;strong&gt;(정말 가벼울까?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;일단 다운로드를 받는데 인터넷속도가 느려서 40분정도 걸렸다.. (빠르면 약 20분 소요)&lt;br /&gt;
백업을 하지 않았으므로 시간이 오래걸리는 클린설치는 생략하도록 한다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(맥북아 미안하다 정리해주지 못해서)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;다운로드를 받기 시작하면 런치패드에도 아래 그림처럼 새로운 아이콘이 생성된다.&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-l_X0S_40Ufc/XrTRzeFPktI/AAAAAAAAAsA/yAKrWXFtwUImHZoE4-cbpV6B44ffqHs4gCLcBGAsYHQ/s1600/mojave3.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
맥북은 다운로드하고 설치를 하는데 발열이 심하다. (다른 노트북도 그런가요?)&lt;br /&gt;
다운로드를 마치고 설치를 진행할 때 나는 인터넷(WIFI)을 끄는 편이다.&lt;br /&gt;
(이미 6GB를 다운받았는데 인터넷이 설마 필요하겠어 ?)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-kGdbQG4BtfI/XrTR08-TbCI/AAAAAAAAAsM/5K0rpce8j7I94XA_TvvKh062TG3SMHAegCLcBGAsYHQ/s1600/mojave4.png&quot; alt=&quot;img4&quot; /&gt;
그런데 인터넷이 필요하더라… (뜨헉!)&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3분간 설치한 자료가 모두 날라간 것 같고 다시 설치했다.
&lt;img src=&quot;https://1.bp.blogspot.com/-3Rs5eP35q5w/XrTR0xEUmSI/AAAAAAAAAsI/kPoy3v_XqGYwzSniZ02j3W87gIkM4uG7gCLcBGAsYHQ/s1600/mojave5.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화면에서 보이는 설치가 완료됬으면&lt;br /&gt;
맥이 재부팅이 된 후 사과 아이콘에서 20분정도 백그라운드 설치? 가 진행된다.&lt;br /&gt;
이때 겁나게 맥이 뜨거워 진다. &lt;del&gt;&lt;strong&gt;(거짓말 안하고 계란 후라이 구울 정도 ?)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
맥은 뜨거운 열기를 끝내 버티고 백그라운드 설치가 완료했다.&lt;/p&gt;

&lt;p&gt;음 다시 재부팅을 하고 보니까 Mojave의 메인 화면이 눈에 들어온다.&lt;br /&gt;
이제 다크모드 감성을 즐기면 되는 것인가 ?
&lt;del&gt;&lt;strong&gt;눈아 오래 버텨줘&lt;/strong&gt;&lt;/del&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-ZyPx-4xldlg/XrTR22pPxGI/AAAAAAAAAsU/0H4MTP4Jzh4f0O4bCxtSY-GtiavUEdz4ACLcBGAsYHQ/s1600/mojave_final.png&quot; alt=&quot;img5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mojave에서 처음으로 도입된 스택이란 기능을 써보았는데&lt;br /&gt;
바탕화면을 한방에 정리해주는 것은 가장 마음에 들었다. 하지만 불편한 것도 있었다..&lt;br /&gt;
앞으로 써보고 후기글도 남겨보겠다.&lt;br /&gt;
&lt;strong&gt;글 다썻다아 ~&lt;/strong&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="모하비" /><category term="Mojave" /><category term="업데이트" /><category term="Update" /><summary type="html">[MacOS] 뒤늦은 모하비(Mojave) 10.13.6 업데이트 (이미지)</summary></entry><entry><title type="html">[MacOS] Mojave, Safari 다크모드 문제점 그리고 앱 추천 (이미지)</title><link href="https://tars-c.github.io/mojave-darkmode-darkeader-app/2020/05/07" rel="alternate" type="text/html" title="[MacOS] Mojave, Safari 다크모드 문제점 그리고 앱 추천 (이미지)" /><published>2020-05-07T00:00:00+09:00</published><updated>2020-05-07T00:00:00+09:00</updated><id>https://tars-c.github.io/mojave-darkmode-darkeader-app/2020/05/MacOS-Mojave%20DarkReader%20App</id><content type="html" xml:base="https://tars-c.github.io/mojave-darkmode-darkeader-app/2020/05/07">&lt;p&gt;이 글이 앱 홍보가 될 수도 있는데&lt;br /&gt;
회사나 남한테 부탁받는 것이 아닌 내돈쓰고 내가 후기를 작성한 것이니 참고 바랍니다.&lt;/p&gt;

&lt;p&gt;모하비를 설치하고 파인더를 둘러보고 설정창도 봤는데&lt;br /&gt;
너무 마음에 들었다. (다크모드 내맘에 딱인걸 ?)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이제 구글좀 한번 들어가볼까 하다가 사파리를 눌렀다.
사파리를 키는 순간 (두둥!)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-ho57yY-LW2Q/XrS8kpuYzHI/AAAAAAAAAq8/eQ1Z0UxmZ7YO6vZYzb4SFE-1bGWtOmJ8ACLcBGAsYHQ/s1600/darkmode_main.png&quot; alt=&quot;img1&quot; /&gt;
이럴거면 도대체 왜 내가 설치했지 ? 라는 생각이 한가득이었다.&lt;br /&gt;
구글이 시작 페이지인데 브라우저 화면이 화이트톤 그자체였다.&lt;br /&gt;
시간은 시간대로 날리고 허무한 느낌만 가득했다..&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
타이틀 및 메뉴바만 다크모드가 되고&lt;br /&gt;
브라우저 화면은 다크모드가 되지 않다니..&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;(이것이 애플님께서 말씀하시는 다크모드 갬성인가 ?)&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분명 나랑 똑같은 일을 겪은 사람들이 있을거라고 판단하고&lt;br /&gt;
검색을 해봤다.&lt;/p&gt;

&lt;p&gt;한가지 얻은 결론은….&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;사파리에서 브라우저 화면이 다크해지는 건 지원하지 않습니다.&lt;br /&gt;
CSS를 이용한 다크모드를 지원하며 사용하려면&lt;br /&gt;
웹사이트에서 스타일을 따로 설정한 경우 지원이 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대표적으로 다크모드 CSS를 설정한 웹사이트가 클리앙이다. &lt;strong&gt;&lt;del&gt;(역시 클라앙은 맥잘알)&lt;/del&gt;&lt;/strong&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-iYAB4pOChXU/XrS8hDqOueI/AAAAAAAAAqU/un_tIK3oHhQLqdalA1CyvuygZhn3hxGIgCLcBGAsYHQ/s1600/darkmode_clien.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;흠 …&lt;br /&gt;
문제점은 파악했으니 이제 해결법을 찾아보도록 한다.&lt;br /&gt;
앱스토어에 dark mode라 검색해보았고&lt;br /&gt;
사파리에서 다크모드를 지원햊는 앱을 발견했다.&lt;br /&gt;
이름은 말 그대로 DarkMode.&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-2rTUw4JTANU/XrS8giQFMyI/AAAAAAAAAqQ/b_f7bFLkd2MSxKStW5lb2vhHGET3yNdSACLcBGAsYHQ/s1600/darkmode_app.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;후기를 찾아보니까 안좋다는 말이 있어서 패스했다.&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-Gh_uUNtBqMU/XrS8lYqUWjI/AAAAAAAAArA/FXz7HYXhKvEiTn2l0I6wXu6zsBJ7xckjwCLcBGAsYHQ/s1600/darkmode_review.png&quot; alt=&quot;img4&quot; /&gt;&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;(유튜브 동영상을 봤을 땐 좋아보였는데)&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;darkreader&quot;&gt;DarkReader&lt;/h2&gt;
&lt;p&gt;” mojave safari dark mode “ 구글에 검색해서 찾다보니 동영상 하나가 눈에 들어왔다.&lt;br /&gt;
동영상을 요약하자면 &lt;code class=&quot;highlighter-rouge&quot;&gt;DarkReader&lt;/code&gt; 앱 기능을 소개하는 동영상이었다.&lt;br /&gt;&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/8FvvrUW7UjI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br /&gt;
동영상을 보고 나름 괜찮아보였던 앱이었다. &lt;del&gt;&lt;strong&gt;(동영상에서 설명은 알아먹지 못했다)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
앱스토어 후기도 전체적으로 살펴본 결과&lt;br /&gt;
평점이 심각하게 낮은게 없어보여서 그냥 눈감고 질렀다.&lt;br /&gt;
무료이면 좋겠지만 가격이 조금있었다. (5,900원)&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;(애플님께서 앱 개발자에게 연마다 등록비 명목으로 돈을 지불하기 때문에 어쩔 수 없다)&lt;/del&gt;&lt;/strong&gt;&lt;br /&gt;
간식 한번 안먹고 병원 안가는 셈치고 바로 질렀다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-C1hks8Ibf_8/XrS8hIHwQcI/AAAAAAAAAqY/wvCn3m1x8R8ou6YzGQQhiXiwphhOpD_zwCLcBGAsYHQ/s1600/darkmode_darkreader_app.png&quot; alt=&quot;img5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사용해본 결과 개인적으로 2%정도 아쉽지만 너무 좋다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;기능을 간략히 나열해보자면
    &lt;ul&gt;
      &lt;li&gt;사이트별 커스텀 테마&lt;/li&gt;
      &lt;li&gt;단축키를 이용한 다크모드 ON/OFF&lt;/li&gt;
      &lt;li&gt;전체 윈도우를 대상으로 다크모드 ON/OFF&lt;/li&gt;
      &lt;li&gt;PDF 다크모드 ON/OFF&lt;/li&gt;
      &lt;li&gt;테마 (Monokai, Abyss 같은 개발 프로그램 테마가 아니다!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;테마는 특정 색상의 집합을 적용하는 것이 아니라&lt;br /&gt;
부가적인 요소(Sepia, GrayScale, Birghtness, Contrast)를 변경할 수 있다는 것이다.&lt;br /&gt;
테마보단 밝기나 채도를 변경할 수 있는 필터라고 하는게 맞는거 같다.&lt;/p&gt;

&lt;p&gt;솔직히 색상 계열 테마를 사용자가 설정할 수 있으면 Best of Best아닌가&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;뭐.. 그래도 만족한다.&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-JjtJMdaaNZg/XrS8h5jVEWI/AAAAAAAAAqk/tMW0Eq0i1v8X6Abfl8tw31qayDFv0ZvAACLcBGAsYHQ/s1600/darkmode_darkreader_apply.png&quot; alt=&quot;img6&quot; /&gt;&lt;br /&gt;
설치를 하면 사파리 메뉴바 상단에 DarkReader 앱 아이콘이 생긴다.&lt;br /&gt;
그걸 눌러서 조절하면 된다.&lt;/p&gt;

&lt;p&gt;아쉬운게 색상별 테마 기능이 없는 것과 macOS만 유료이고&lt;br /&gt;
나머진 무료 + 오픈소스 그자체이다.&lt;/p&gt;

&lt;p&gt;길게 말하면 뭐하나 ?&lt;br /&gt;
적용 전, 적용 후를 보는게 낫지&lt;/p&gt;

&lt;h3 id=&quot;다크모드-적용-전&quot;&gt;다크모드 적용 전&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://1.bp.blogspot.com/-BEpBU0WsbJ0/XrS8iNKTEII/AAAAAAAAAqo/rWvxcVfBpJo_fYhNe2u0yOhL_I455yn2ACLcBGAsYHQ/s1600/darkmode_disable.png&quot; alt=&quot;img7&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;다크모드-적용-후&quot;&gt;다크모드 적용 후&lt;/h3&gt;
&lt;p&gt;다이나믹 모드라 한다.&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-ip_jkXHh6uM/XrS8ik5d90I/AAAAAAAAAqs/SudUQcIpJ6YI3gbJdr5sq93TqXdSZ5VYgCLcBGAsYHQ/s1600/darkmode_dynamic.png&quot; alt=&quot;img8&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;필터-효과-적용-후&quot;&gt;필터 효과 적용 후&lt;/h3&gt;
&lt;p&gt;(필터는 색상을 바꾸는게 아니라 빛의 밝기를 조절하는 것이다)&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-NEsWdHtOwHM/XrS8jvBIIyI/AAAAAAAAAq0/WfDDS8qtB1I_zKETrMLDZraACqkskNd3QCLcBGAsYHQ/s1600/darkmode_filter.png&quot; alt=&quot;img9&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;사실 밝은 화이트톤이 최고인거 같다.&lt;br /&gt;
근데 눈 건강에 안좋다면 괜찮은 다크모드를 쓰는 것도 좋지아니한가 ?&lt;br /&gt;
다이나믹 모드를 사용하면 뿌연 보라색상이 마음에 안들어서 필터를 씌우고 사용한다.&lt;br /&gt;
&lt;strong&gt;&lt;del&gt;(뿌연 색보단 밝은 핑크색이 낫지)&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 깃허브를 다크모드를 감상해보자&lt;br /&gt;
&lt;img src=&quot;https://1.bp.blogspot.com/-3px-3Q4b-_A/XrS8kLevm9I/AAAAAAAAAq4/Y5RBLQkWNrsfUixVX588RnoSzywWLDhHgCLcBGAsYHQ/s1600/darkmode_github.png&quot; alt=&quot;img10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오오옷 역시 좋아 ㅠㅠ&lt;br /&gt;
역시 돈투자한 보람이 있군&lt;br /&gt;
&lt;img src=&quot;/assets/images/Fun/prodo_thumb_up.png&quot; alt=&quot;img11&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;으음, 처음엔 몰랐다..&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
+ 네이버 블로그는 Dynamic 모드로 다크모드 잘되는데 필터를 사용할 경우는 작동을 안한다.
&lt;strong&gt;&lt;del&gt;(정보습득은 msdn, google, tistory로 하지만..)&lt;/del&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;글 다썻다아 ~&lt;/strong&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="다크모드" /><category term="DarkMode" /><category term="모하비" /><category term="Mojave" /><category term="다크리더" /><category term="DarkReader" /><category term="MacOS" /><category term="macOS" /><summary type="html">[MacOS] Mojave, Safari 다크모드 문제점 그리고 앱 추천 (이미지)</summary></entry><entry><title type="html">[C++] Serialization : 설명</title><link href="https://tars-c.github.io/Serialiization/2020/05/06" rel="alternate" type="text/html" title="[C++] Serialization : 설명" /><published>2020-05-06T00:00:00+09:00</published><updated>2020-05-06T00:00:00+09:00</updated><id>https://tars-c.github.io/Serialiization/2020/05/Serialization%20-%20%EC%84%A4%EB%AA%85</id><content type="html" xml:base="https://tars-c.github.io/Serialiization/2020/05/06">&lt;h2 id=&quot;직렬화serialization란-&quot;&gt;직렬화(Serialization)란 ?&lt;/h2&gt;
&lt;p&gt;크고 복잡한 데이터(Object)를 가장 단순한 byte형태(Binary Data)로 변환하는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;반대로 가장 단순한 형태로 저장된 데이터들을 복잡한 데이터(Object)로 변환하는 것을&lt;br /&gt;
역직렬화(Deserialiization)라 합니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/CPP/Serialiization.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용 예시는 크게 3가지입니다.
    &lt;ul&gt;
      &lt;li&gt;서로 다른프로세스 통신(IPC)&lt;/li&gt;
      &lt;li&gt;파일 입출력(File I/O)&lt;/li&gt;
      &lt;li&gt;네트워크 통신(Socket)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;직렬화를-사용하는-이유는-&quot;&gt;직렬화를 사용하는 이유는 ?&lt;/h2&gt;
&lt;p&gt;Object객체는 상당히 복잡한 형태로 이루어져 있습니다.&lt;br /&gt;
객체를 파일로 저장하거나 다른 컴퓨터에게 전송을할 때 Stream을 이용합니다.&lt;/p&gt;

&lt;p&gt;Stream을 이용해 이미지 파일을 복사한다고 할 때&lt;br /&gt;
기존 파일을 Binary로 읽어(Read)들이고 읽어들인 데이터를 쓰게(Write) 됩니다.&lt;/p&gt;

&lt;p&gt;Stream은 큰 데이터를 한번에 보낼 수 없고 원시타입(Primitive)의 데이터를 전송할 수 있습니다.&lt;br /&gt;
큰 데이터들은 직렬화(Serialiization)를 이용하여 전송가능한 원시타입으로 변환하여&lt;br /&gt;
Stream으로 데이터를 교환하거나 전송합니다.&lt;/p&gt;

&lt;h2 id=&quot;직렬화한-데이터를-사용자가-직접-볼-수는-없는가-&quot;&gt;직렬화한 데이터를 사용자가 직접 볼 수는 없는가 ?&lt;/h2&gt;
&lt;p&gt;직렬화된 데이터는 사용자가 직접 보기 힘듭니다.&lt;br /&gt;
HEX Viewer를 이용해 직렬화된 값을 16진수로 확인할 수 있습니다.&lt;br /&gt;
이는 저장된 파일을 HEX Viewer로 보는 것과 비슷합니다.&lt;/p&gt;

&lt;p&gt;이미지 같은 경우는 헤더를 포함한 데이터 자체만을 저장했을 때&lt;br /&gt;
뷰어를 통해 이미지를 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://rockdrumy.tistory.com/1044&quot; target=&quot;_blank&quot;&gt;이미지 출처: Tistory 드럼치는 프로그래머&lt;/a&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="직렬화" /><category term="Serialization" /><category term="Serialize" /><summary type="html">[C++] Serialiization : 설명</summary></entry><entry><title type="html">[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%95%EB%B3%B4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%A0%95%EB%B3%B4%20%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%95%EB%B3%B4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;프로그램 개발 시 이미지의 크기 정보 및 가지고 있는 정보가 필요할 때가 있습니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CImage 클래스에서 제공하는 함수&lt;/code&gt;에서 이미지 정보를 가져오는 함수를 알아봅니다.&lt;/p&gt;

&lt;h2 id=&quot;이미지-정보-가져오기&quot;&gt;이미지 정보 가져오기&lt;/h2&gt;

&lt;h3 id=&quot;가로폭-width-가져오기&quot;&gt;가로(폭, Width) 가져오기&lt;/h3&gt;
&lt;p&gt;가로 폭 정보를 제공해주는 함수는 GetWidth() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;세로높이-height-가져오기&quot;&gt;세로(높이, Height) 가져오기&lt;/h3&gt;
&lt;p&gt;세로 높이 정보를 제공해주는 함수는 GetHeight() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pixel당-비트-수bpp-가져오기&quot;&gt;Pixel당 비트 수(BPP) 가져오기&lt;/h3&gt;
&lt;p&gt;Pixel당 비트 수 정보를 제공해주는 함수는 GetBPP() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;x-y-위치의-픽셀-주소-및-컬러값-가져오기&quot;&gt;x, y 위치의 픽셀 주소 및 컬러값 가져오기&lt;/h3&gt;
&lt;p&gt;(x, y) 위치의 픽셀 주소값 제공해주는 함수는 GetPixelAddress() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;COLORREF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetPixelAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>타스 (TARS-C)</name></author><category term="이미지" /><category term="Image" /><category term="정보" /><category term="GetWidth" /><category term="GetHeight" /><category term="GetBPP" /><category term="GetPixelAddress" /><category term="가로" /><category term="Width" /><category term="세로" /><category term="Height" /><category term="화소당비트" /><category term="BPP" /><category term="픽셀" /><category term="Pixel" /><category term="주소" /><category term="Address" /><summary type="html">[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)</summary></entry><entry><title type="html">[MFC] Bitmap Format (DIB, DDB) : 설명</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%8F%AC%EB%A7%B7-(DIB,-DDB)/" rel="alternate" type="text/html" title="[MFC] Bitmap Format (DIB, DDB) : 설명" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80%20%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94%20%EB%B9%84%ED%8A%B8%EB%A7%B5%20%ED%8F%AC%EB%A7%B7%20(DIB,%20DDB)</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%8F%AC%EB%A7%B7-(DIB,-DDB)/">&lt;ul&gt;
  &lt;li&gt;Windows에서 비트맵은 총 2가지 포맷을 지원합니다.
    &lt;ul&gt;
      &lt;li&gt;DDB(Device Dependent Bitmap)&lt;/li&gt;
      &lt;li&gt;DIB(Device Indepedent Bitmap)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ddb-과거-화려했던-스타&quot;&gt;DDB (과거 화려했던 스타)&lt;/h2&gt;
&lt;p&gt;Windows 3.0 이전 버전에서 사용되던 포맷 방식입니다.&lt;br /&gt;
하지만 오늘날에서도 쓸 수 있습니다.&lt;br /&gt;
DC에 SelectObject() 할 수 있는 포맷&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(개발자라면 DDB도 알아야합니다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;장치에 의존 및 독립되지 않은 비트맵을 의미합니다.&lt;br /&gt;
과거 비트맵을 출력했던 방식에서 사용됩니다.&lt;/p&gt;

&lt;p&gt;장치에 독립되지 않고 의존적이므로 내 장치가 흑백 장치라면&lt;br /&gt;
어떤 이미지든 흑백으로 밖에 이미지를 볼 수 밖에 없는 것입니다.&lt;/p&gt;

&lt;p&gt;DIB의 장점은 연산할 때 속도가 빠릅니다.&lt;br /&gt;
단점은 컬러 비트맵을 출력할 수 있는 장치에서는 흑백 비트맵을 출력할 수 없습니다.&lt;/p&gt;

&lt;p&gt;Createbitmap() 함수를 사용하여 DDB 비트맵을 생성할 수 있습니다.&lt;br /&gt;
장치에 독립적이므로 비트맵 헤더 구조가 간단하게 이루어져있습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tagBITMAP&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmWidthBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmPlanes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmBitsPixel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BITMAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;dib-지금도-핫한-스타&quot;&gt;DIB (지금도 핫한 스타)&lt;/h2&gt;
&lt;p&gt;Windows 3.0 버전부터 사용되온 포맷 방식입니다.&lt;br /&gt;
지금까지도 흔하게 쓰고 있는 비트맵입니다.&lt;/p&gt;

&lt;p&gt;비트맵 파일을 저장될 때에도 DIB 포맷을 사용합니다.&lt;br /&gt;
DC에 SelectObject() 할 수 없는 포맷&lt;/p&gt;

&lt;p&gt;장치랑 상관없이 어느장치에나 색상을 완벽하게 출력할 수 있습니다.&lt;br /&gt;
활용도가 DIB보단 훨씬 넓고 광범위합니다.&lt;br /&gt;
전체적으로 파일이 가지고 있는 데이터가 크므로 연산 속도가 느립니다.&lt;/p&gt;

&lt;p&gt;흑백만 출력할 수 있는 장치에서&lt;br /&gt;
파일 자체가 비트맵 정보를 가지고 있기 때문에 컬러로 출력할 수 있습니다.&lt;/p&gt;

&lt;p&gt;CreateCompatibleBitmap() 함수를 사용하여 DIB 비트맵을 변환 및 생성할 수 있습니다.&lt;br /&gt;
색상정보를 가지고 있기 때문에 비트맵 헤더의 크기는 DIB 비트맵 헤더보다 큽니다.&lt;br /&gt;
헤더는 BITMAPFILEHEADER, BITMAPINFOHEADER 로 구성되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DDB
    &lt;ul&gt;
      &lt;li&gt;과거 화려했던 스타 (Windows 3.0 이전 버전, 지금까지도 사용할 수 있음)&lt;/li&gt;
      &lt;li&gt;장치에 묶여있음(종송적)&lt;/li&gt;
      &lt;li&gt;장치가 지원하는 색상만 출력할 수 있음&lt;/li&gt;
      &lt;li&gt;비트맵 헤더가 매우 단순하고 가벼움&lt;/li&gt;
      &lt;li&gt;연산 속도는 빠름&lt;/li&gt;
      &lt;li&gt;생성 및 파괴 오버헤드 적음&lt;/li&gt;
      &lt;li&gt;DC에 SelectObject() 가능 &lt;del&gt;&lt;strong&gt;(Only You)&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;Createbitmap() 함수를 이용한 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DIB
    &lt;ul&gt;
      &lt;li&gt;지금도 핫한 스타 (WIndows 3.0 버전에서부터 사용됨)&lt;/li&gt;
      &lt;li&gt;장치랑 상관없이 자유로움 &lt;del&gt;&lt;strong&gt;(장치에서의 해방이다~)&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;장치가 지원하지 않지만 다른 색상도 출력할 수 있음&lt;/li&gt;
      &lt;li&gt;색상 정보를 가지고 있으므로 비트맵 헤더가 복잡하고 큼&lt;/li&gt;
      &lt;li&gt;연산속도는 DDB보다 느림&lt;/li&gt;
      &lt;li&gt;생성 및 파괴는 DIB보다 비효율적&lt;/li&gt;
      &lt;li&gt;DC에 SelectObject() 불가능! (내부 변환과정 거쳐야함)&lt;/li&gt;
      &lt;li&gt;CreateCompatibleBitmap() 함수를 이용한 변환 및 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>타스 (TARS-C)</name></author><category term="DIB" /><category term="DDB" /><category term="장치" /><category term="Device" /><category term="비트맵" /><category term="Bitmap" /><category term="포맷" /><category term="Format" /><category term="이미지포맷" /><category term="ImageFormat" /><summary type="html">[MFC] Bitmap Format (DIB, DDB) : 설명</summary></entry><entry><title type="html">[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog</title><link href="https://tars-c.github.io/library/spdlog/2020/05/05" rel="alternate" type="text/html" title="[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/library/spdlog/2020/05/%EB%B9%A0%EB%A5%B8%20%EB%A1%9C%EA%B7%B8%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%20%EC%86%8C%EA%B0%9C</id><content type="html" xml:base="https://tars-c.github.io/library/spdlog/2020/05/05">&lt;p&gt;C++ 개발자방에서 한분이 라이브러리를 소개시켜주었습니다.&lt;br /&gt;
벤치마크 성능을 보니까 빠르고 좋아보여 공유하고자 합니다.&lt;br /&gt;
자세한건 아래 링크를 참고해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gabime/spdlog&quot; target=&quot;_blank&quot;&gt;Project: spldog Library Repository&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://travis-ci.org/gabime/spdlog&quot;&gt;&lt;img src=&quot;https://travis-ci.org/gabime/spdlog.svg?branch=v1.x&quot; alt=&quot;Build Status&quot; /&gt;&lt;/a&gt;   &lt;a href=&quot;https://ci.appveyor.com/project/gabime/spdlog&quot;&gt;&lt;img src=&quot;https://ci.appveyor.com/api/projects/status/d2jnxclg20vd0o50?svg=true&quot; alt=&quot;Build status&quot; /&gt;&lt;/a&gt;   &lt;a href=&quot;https://github.com/gabime/spdlog/releases/latest&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/release/gabime/spdlog.svg&quot; alt=&quot;Release&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지원하는 플랫폼
    &lt;ul&gt;
      &lt;li&gt;Android&lt;/li&gt;
      &lt;li&gt;Linux (FreeBSD, OpenBSD, Solaris, AIX)&lt;/li&gt;
      &lt;li&gt;macOS (clang 3.5 later)&lt;/li&gt;
      &lt;li&gt;Windows (msvc 2013 later, cygwin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지원하는 설치 및 패키지 매니저
    &lt;ul&gt;
      &lt;li&gt;cmake&lt;/li&gt;
      &lt;li&gt;Homebrew&lt;/li&gt;
      &lt;li&gt;MacPorts&lt;/li&gt;
      &lt;li&gt;FreeBSD&lt;/li&gt;
      &lt;li&gt;Fedora&lt;/li&gt;
      &lt;li&gt;Gentoo&lt;/li&gt;
      &lt;li&gt;Arch Linux&lt;/li&gt;
      &lt;li&gt;vcpkg&lt;/li&gt;
      &lt;li&gt;conan&lt;/li&gt;
      &lt;li&gt;conda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
  이 라이브러리는 JetBrains 라이센스 기증을 받아 제작되었습니다.&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="spdlog" /><category term="로그" /><category term="Logging" /><category term="Log" /><category term="라이브러리" /><category term="Library" /><summary type="html">[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog</summary></entry><entry><title type="html">[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기</title><link href="https://tars-c.github.io/bitmap-header-get-file-size/2020/05/04" rel="alternate" type="text/html" title="[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기" /><published>2020-05-04T00:00:00+09:00</published><updated>2020-05-04T00:00:00+09:00</updated><id>https://tars-c.github.io/bitmap-header-get-file-size/2020/05/%EB%B9%84%ED%8A%B8%EB%A7%B5%20%ED%97%A4%EB%8D%94%20%EC%9D%BD%EC%96%B4%EC%84%9C%20%ED%8C%8C%EC%9D%BC%20%ED%81%AC%EA%B8%B0%20%EC%95%8C%EC%95%84%EC%98%A4%EA%B8%B0</id><content type="html" xml:base="https://tars-c.github.io/bitmap-header-get-file-size/2020/05/04">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;비트맵 파일 헤더 중 파일 크기 정보에 해당하는 데이터를 읽어서 파일 크기를 출력합니다.&lt;br /&gt;
비트맵 헤더 시작 위치는 0x0에 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비트맵-헤더&quot;&gt;비트맵 헤더&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;비트맵 헤더는 총 2가지로 구성되어 있으며 총 54byte 크기를 차지하고 있습니다.
    &lt;ul&gt;
      &lt;li&gt;BITMAPFILEHEADER (14byte)&lt;/li&gt;
      &lt;li&gt;BITMAPINFOHEADER (40byte)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일 크기 정보가 명시된 헤더는 Biamp File Header(BITMAPFILEHEADER) 입니다.&lt;br /&gt;
아래 그림은 비트맵 파일 전체 구조입니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/bmpheader.jpg&quot; alt=&quot;img1&quot; /&gt;
파일 크기 정보를 구해오기 위해 중요하게 봐야할 것은 FileSize 입니다.&lt;br /&gt;
파일 크기 정보를 가진 데이터는 4Byte이며,&lt;br /&gt;
시작위치는 2번째 위치에 있습니다. (start based 0)&lt;/p&gt;

&lt;p&gt;비트맵 헤더에서 파일 크기 정보를 가지고 있는 부분을 읽어서 출력하면 됩니다.&lt;br /&gt;
주의할 점은 일반적으로 메모리를 읽어들이는 방식은 BigEndian입니다.&lt;br /&gt;
하지만 헤더의 데이터는 LittleEndian 방식으로 되어있으며 변환작업이 필요합니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(변환 작업은 그냥 비트를 밀면 됩니다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;파일을 Open 후 seekg() 함수를 사용해서 파일을 읽어들이는 위치를 지정합니다.&lt;br /&gt;
파일 크기 정보를 얻으려면 2번째 위치부터 4byte 읽어옵니다.&lt;/p&gt;

&lt;p&gt;LittleEndian 방식의 데이터를 비트 연산자를 이용해 비트를 밀어서 Bigendian 데이터로 출력합니다.&lt;/p&gt;

&lt;h2 id=&quot;f비트맵-파일-크기를-얻어오는-함수&quot;&gt;[F]비트맵 파일 크기를 얻어오는 함수&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBitmapFileSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBitmapFileSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ifstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seekg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//string filePath = &quot;Desktop/myBmp.bmp&quot;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//getBitmapFileSize(filePath);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/resultbmpfilesize.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/CImage/bmpfilesizeinfo.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="cpp" /><category term="비트맵" /><category term="bitmap" /><category term="bmp" /><category term="header" /><category term="헤더" /><category term="파일크기" /><category term="파일읽기" /><category term="파일 크기 정보" /><category term="BITMAPFILEHEADER" /><category term="BITMAPINFOHEADER" /><summary type="html">[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기</summary></entry><entry><title type="html">[C++] 비트 연산 Bitwise</title><link href="https://tars-c.github.io/bitwise/2020/05/03" rel="alternate" type="text/html" title="[C++] 비트 연산 Bitwise" /><published>2020-05-03T00:00:00+09:00</published><updated>2020-05-03T00:00:00+09:00</updated><id>https://tars-c.github.io/bitwise/2020/05/%EB%B9%84%ED%8A%B8%20%EC%97%B0%EC%82%B0%20Bitwise</id><content type="html" xml:base="https://tars-c.github.io/bitwise/2020/05/03">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;저에게 XOR은 조금 친근하지 못한 연산자였는데&lt;br /&gt;
한가지 쓰임을 알게게 되어 비트 연산 전체를 포스팅하게 되었습니다.&lt;br /&gt;
비트 연산을 한다고 해서 피연산자를 2개 요구하는 연산자들은 결과가 바로 반영되지 않습니다.&lt;br /&gt;
비트 연산도 산술연산자처럼 축약형으로 사용할 수 있습니다. (&amp;amp;=, |=, ^=, «=, »=)&lt;/p&gt;

&lt;p&gt;비트연산은 다른 연산자에 비해 처리 속도가 빠릅니다.&lt;br /&gt;
공부를 할때 숫자를 막 써놔도 비트연산은 눈으로 봐도 잘 들어오지 않습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;화면에 계산기를 켜두고 하나씩 실습해보면 누구나 쉽게 터득할 수 있습니다.&lt;br /&gt;
비트연산 관련 프로그래밍 시 계산기를 이용하면 빠르게 작업을 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예시에서 사용되는 타입 크기는 임의 크기인 1byte입니다.&lt;br /&gt;
기본 int 타입 크기는 x86 환경에서 4byte인 점을 주의하셔야 합니다.&lt;br /&gt;
(자료형의 크기가 클 수록 비트가 복잡하므로 나머지 3byte는 명시 안함)&lt;/p&gt;

&lt;p&gt;비트는 10진수가 가진 값을 2의 n승 꼴로 표현할 수 있습니다.&lt;br /&gt;
10진수와 관계지어 비트가 차지하고 있는 위치에 대해 알아야합니다.&lt;br /&gt;
아래에 비트연산을 이해하기 위해서는 다음과 같은 개념을 아셔야 합니다.&lt;br /&gt;
첫번째 비트: 2의 0승 = 1&lt;br /&gt;
두번째 비트: 2의 1승 = 2&lt;br /&gt;
세번째 비트: 2의 3승 = 4&lt;br /&gt;
네번째 비트: 2의 4승 = 8&lt;br /&gt;
다섯번째 비트: 2의 5승 = 16&lt;/p&gt;

&lt;p&gt;비트가 0000 1111 로 구성되어 있으면&lt;br /&gt;
10진수 값은  15가 됩니다. (1 + 2 + 4 + 8)&lt;/p&gt;

&lt;h2 id=&quot;or-연산&quot;&gt;OR 연산&lt;/h2&gt;
&lt;p&gt;OR 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;OR 비트연산은 두개의 비트 중 하나만 1이면 결과가 참(1)이 되는 것을 의미합니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 식에서 A와 B는 OR 연산자(|)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0000 0010 :: 2&lt;br /&gt;
0000 0111 :: 7(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 오른쪽이 첫번째 비트)&lt;br /&gt;
(5의 1번째 비트 1 | 2의 1번째 비트 0) 연산 = 1&lt;br /&gt;
(5의 2번째 비트 0 | 2의 2번째 비트 1) 연산 = 1&lt;br /&gt;
(5의 3번째 비트 1 | 2의 3번째 비트 0) 연산 = 1&lt;br /&gt;
나머지 비트 모두 0&lt;br /&gt;
연산 결과: 0000 0111 (10진수: 7)이 나오게 됩니다.&lt;/p&gt;

&lt;p&gt;또, OR 연산은 두개의 피연산자가 가진 값에 해당하는 비트가 중복되지 않는 선에서 더하기에도 쓰인다는 겁니다.&lt;br /&gt;
5와 2를 OR 비트 연산했는데 결과값이 7이 나왔죠 ? &lt;del&gt;&lt;strong&gt;(어이쿠! 더해졌네?)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
반대로 비트가 중복되는 경우를 보자면&lt;br /&gt;
1과 3을 OR 연산하면 결과가 3이 나오게 되고 덧셈을 못하는 슬픔을 겪게 될 수도 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;덧셈방식을 이용하여 특정 속상값을 부여할 수도 있습니다.&lt;br /&gt;
0000 0000 비어 있는 비트가 있을 때&lt;br /&gt;
0000 0001 10진수 1을 사용하여 OR 연산으로 1비트를 채워줄 수 있고&lt;br /&gt;
0000 0010 두번째 비트도 10진수 2를 사용하여 1을 채워줄 수 있습니다.&lt;br /&gt;
OR 비트 연산을 이용하면 값에 여러가지 속성값을 부여할 수 있습니다. (Flag 연산)&lt;/p&gt;

&lt;p&gt;WINAPI, MFC에서도 스타일처럼 여러개의 속성을 적용시킬 수 있을 때&lt;br /&gt;
OR 비트 연산을 이용해 여러개의 속성을 부여하는 방식을 다음과 같이 사용합됩니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_VISIBLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_CHILD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_THINFRAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;and-연산&quot;&gt;AND 연산&lt;/h2&gt;
&lt;p&gt;AND 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;AND 비트 연산은 두개의 비트 중 둘다 1이어야 결과가 참(1)이 되는 것을 의미합니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 식에서 A와 B는 AND 연산자(&amp;amp;)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0000 0011 :: 3&lt;br /&gt;
0000 0001 :: 1(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 왼쪽이 첫번째 비트)&lt;br /&gt;
(5의 1번째 비트 1 &amp;amp; 3의 1번째 비트 1) 연산 = 1&lt;br /&gt;
(5의 2번째 비트 0 &amp;amp; 3의 2번째 비트 1) 연산 = 0&lt;br /&gt;
(5의 3번째 비트 1 &amp;amp; 3의 3번째 비트 0) 연산 = 0&lt;br /&gt;
나머지 비트 모두 0&lt;br /&gt;
연산 결과: 0000 0001 (10진수: 1)&lt;/p&gt;

&lt;p&gt;또, AND 연산자(&amp;amp;)를 이용해 속성값을 가지고 있는지에 대해 찾을 수도 있습니다.&lt;br /&gt;
말로 설명하는 것보다 코드로 설명드리겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;levelPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//invalid permission&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// success&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;속성에서 관리자의 권한값은 4입니다.&lt;br /&gt;
사용자가 가지고 있는 권한은 유저(1) + 관리자(4)이므로 권한값은 즉, 5입니다.&lt;br /&gt;
4와 5를 AND 연산자(&amp;amp;)를 이용해 비트연산을 진행합니다.&lt;br /&gt;
0000 0101 (10진수: 5)&lt;br /&gt;
0000 0100 (10진수: 4)&lt;/p&gt;

&lt;p&gt;두 수가 가진 비트 중 3번째 비트가 모두 1이므로 AND 연산 결과는 1이 됩니다.&lt;br /&gt;
&lt;strong&gt;(전 개인적으로 접근 불가나 오류 발생하는 코드가 위에 있으면 좋더라구요..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;속성 값이 가진 비트를 뒤집어서 &amp;amp; 연산하면 사용자가 가지고 있는 권한을 뺏을 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;not-연산&quot;&gt;NOT 연산&lt;/h2&gt;
&lt;p&gt;NOT 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 1개가 필요합니다.&lt;/p&gt;

&lt;p&gt;NOT 비트연산은 비트를 모두 뒤집어버리는 것입니다.&lt;br /&gt;
0을 1로, 1을 0으로 바꾼다 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;생각보다 쓰임이 적다고 생각되는 연산자였습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;알고리즈머 YunGoon님께 관련된 쓰임세를 몇가지 알아왔습니다. 감사합니다.&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
쓰임1과 쓰임2에 해당하는 - 는 부호 연산자입니다. &lt;del&gt;(빼기가 아닙니다)&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;-n은-n1-꼴로-사용될-수-있다&quot;&gt;-~n은 n+1 꼴로 사용될 수 있다&lt;/h3&gt;
&lt;p&gt;10진수 4를 비트로 표현하면 0000 0100 입니다.&lt;br /&gt;
이를 NOT 연산하여 비트를 뒤집어 보면 1111 1011이 됩니다.&lt;br /&gt;
그리고 맨 앞에 있는 -로 부호를 반전시켜주면 비트는 0000 0101이 되고 5가 되는 것입니다.&lt;br /&gt;
부호를 반전시킬 때는 NOT 연산으로 비트를 모두 뒤집고 맨 오른쪽 비트에 1을 더하면 됩니다.&lt;br /&gt;
1을 더하는 이유는 보수의 변환과정에서 1을 더했기 때문에 다시 더해주는 것입니다.&lt;/p&gt;

&lt;p&gt;0000 0100 (10진수: 4)&lt;br /&gt;
1111 1011 (NOT) (10진수: -5)&lt;br /&gt;
0000 0101 (부호반전) (10진수: 5)&lt;/p&gt;

&lt;h3 id=&quot;-n은-n-1-꼴로-사용할-수-있다&quot;&gt;~-n은 n-1 꼴로 사용할 수 있다&lt;/h3&gt;
&lt;p&gt;쓰임1과 매우 비슷합니다. 이번엔 7로 해보겠습니다.&lt;br /&gt;
10진수 7을 비트로 표현하면 0000 0111 입니다.&lt;br /&gt;
2의 보수로 만드는 방법을 이용해 -7로 만들어주는 것입니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;음수를 표현할 때 2의 보수를 사용하는데 변환과정을 아주 간략하게 설명드리면&lt;br /&gt;
양수 7이 가진 비트를 뒤집고 맨 오른쪽 비트에 1을 더해줍니다.&lt;br /&gt;
-7에서 NOT 연산을 하여 비트를 뒤집어주면 6이 됩니다.&lt;/p&gt;

&lt;p&gt;0000 0111 (10진수: 7)&lt;br /&gt;
1111 1001 (부호반전) (10진수: -7)&lt;br /&gt;
0000 0110 (NOT) (10진수: 6)&lt;/p&gt;

&lt;h3 id=&quot;eof라면-루프-탈출에-사용할-수-있다&quot;&gt;EOF라면 루프 탈출에 사용할 수 있다&lt;/h3&gt;
&lt;p&gt;수 많은 컴파일러가 EOF를 -1로 정의합니다.&lt;br /&gt;
-1 값을 가지고 반복문을 사용한다면 NOT 연산을 통해 비트를 뒤집습니다.&lt;br /&gt;
-1 값이 0 으로 변경되고 if, while, for 같은 조건문에서 활용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;1111 1111 (10진수: -1)&lt;br /&gt;
0000 0000 (NOT) (10진수: 0)&lt;/p&gt;

&lt;p&gt;이는 while(~scanf()) { } 처럼 응용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;xor-연산&quot;&gt;XOR 연산&lt;/h2&gt;
&lt;p&gt;XOR 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;XOR 비트연산은 OR과 비슷하면서도 전혀 다릅니다.&lt;br /&gt;
두 수중 비트를 하나씩 비교하여 둘다 1이거나 0일 떄 0을 반환합니다.&lt;br /&gt;
서로 같은 값이면 0, 서로 같지 않으면 1을 반환한다고 생가하시면 됩니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;

&lt;p&gt;숫자 7과 3을 예시로 들어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 식에서 A와 B는 XOR 연산자(^)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0111 :: 7&lt;br /&gt;
0000 0011 :: 3&lt;br /&gt;
0000 0100 :: 4(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 왼쪽이 첫번째 비트)&lt;br /&gt;
(7의 1번째 비트 1 &amp;amp; 3의 1번째 비트 1) 연산 = 0&lt;br /&gt;
(7의 2번째 비트 1 &amp;amp; 3의 2번째 비트 1) 연산 = 0&lt;br /&gt;
(7의 3번째 비트 1 &amp;amp; 3의 3번째 비트 0) 연산 = 1&lt;br /&gt;
나머지 비트 모두 0 또는 1로 같으므로 0&lt;/p&gt;

&lt;p&gt;XOR은 알면 알 수록 신기한 녀석입니다. &lt;del&gt;&lt;strong&gt;(누가 발견한거지?)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
XOR은 이미지 연산이나 교체 알고리즘에 사용됩니다.&lt;br /&gt;
우연히 알파벳을 빠르게 교체하는 문제를 풀면서 새로운 사용 방법을 알게되었습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;이 방법도 알고리즈머 YunGoon님께서 알려주셨습니다. (깊게 생각했으면 스스로 알았을까?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/CPP/bitwise.png&quot; alt=&quot;img1&quot; /&gt;&lt;br /&gt;
위 그림처럼 10진수 32는 비트를 1개만 가지고 있습니다.&lt;br /&gt;
반대로 31은 32가 가지고 있는 비트를 제외한 나머지 하위 비트를 모두 가지고 있습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(이미 알고있는 정보인데도 뭔가 다시 깨달은 느낌이랄까요 ?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;비트가-가득찬-경우&quot;&gt;비트가 가득찬 경우&lt;/h3&gt;
&lt;p&gt;10진수 31과 5를 XOR 연산해보겠습니다.&lt;br /&gt;
0001 1111 :: 31&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0001 1010 :: 26(결과)&lt;/p&gt;

&lt;p&gt;자세한 연산과정은 생략하겠습니다.&lt;br /&gt;
재밌는 사실은 31에서 5를 뺀 값인 26이 나온다는 겁니다.&lt;br /&gt;
주의할 점은 31과 31을 연산하면 0이 나오니 주의해야합니다.&lt;/p&gt;

&lt;h3 id=&quot;비트가-비어-있는-경우&quot;&gt;비트가 비어 있는 경우&lt;/h3&gt;
&lt;p&gt;10진수 32와 5를 XOR 연산해보겠습니다.&lt;br /&gt;
0010 0000 :: 32&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0010 0101 :: 37&lt;/p&gt;

&lt;p&gt;자세한 연산과정은 생략하겠습니다.&lt;br /&gt;
재밌는 사실은 32에서 5를 더한 값인 37이 나온다는 겁니다.&lt;br /&gt;
32가 가지고 있는 비트 중 연산하려는 5의 비트가 비어있는 경우 덧셈을 하게 됩니다.&lt;br /&gt;
&lt;br /&gt;
위 방식을 응용한다면 영어 대소문자를 변환하는 작업에 처리속도를 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;shift-연산&quot;&gt;SHIFT 연산&lt;/h2&gt;
&lt;p&gt;SHIFT 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;, &amp;gt;&amp;gt;&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 피연산자에는 비트를 조작할 데이터를 적고&lt;br /&gt;
오른쪽 피연산자에는 몇칸을 밀 것인지에 대해 적습니다.&lt;/p&gt;

&lt;p&gt;SHIFT 연산은 비트를 오른쪽 혹은 왼쪽으로 이동할 때 사용합니다.&lt;br /&gt;
왼쪽으로 비트가 밀려서 범위를 초과하면 값이 사라지게 됩니다.&lt;/p&gt;

&lt;p&gt;양수는 최상위 부호비트가 0이므로 어떻게 밀어도 상관이 없습니다.&lt;br /&gt;
음수인 경우에 SHIFT 연산할 경우 최상위 비트(MSB, 부호비트)도 같이 밀리기 때문에 주의해야합니다.&lt;/p&gt;

&lt;p&gt;오른쪽으로 « 밀어서 범위 초과로 값이 이상한 경우 오버플로우(overflow)&lt;br /&gt;
왼쪽으로 » 밀어서 범위 초과로 값이 이상한 경우 언더플로우(underflow)라 합니다.&lt;br /&gt;
SHIFT 연산은 단독으로 사용되기보다 | 및 &amp;amp; 연산과 함께 사용되는 편입니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-오른쪽으로-시프트&quot;&gt;SHIFT « (오른쪽으로 시프트)&lt;/h3&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;31 이 가지고 있는 전체 비트를 오른쪽으로 1칸 밀게 됩니다.&lt;br /&gt;
오른쪽으로 비트가 밀리면 빈자리는 0으로 채워집니다.&lt;/p&gt;

&lt;p&gt;0001 1111 :: 31&lt;br /&gt;
0011 1110 :: 62(결과)&lt;br /&gt;
결과를 보면 알 수 있듯이 오른쪽으로 비트를 1칸 밀 수록 2배 커집니다.&lt;br /&gt;
&lt;br /&gt;
그럼 한번에 2칸을 밀면 2배 커질까요 ? 아닙니다.&lt;br /&gt;
4배 커지게 되는데 이는 오른쪽으로 비트를 밀 수록 2의 n승만큼 커지는 것입니다.&lt;/p&gt;

&lt;p&gt;31 « 3을 계산해봅시다.&lt;br /&gt;
2의 3승은 8 즉, 31x8 값인 248이 결과로 산출됩니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-왼쪽으로-시프트&quot;&gt;SHIFT » (왼쪽으로 시프트)&lt;/h3&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;79&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;79 가 가지고 있는 전체 비트를 왼쪽으로 2칸 밀게 됩니다.&lt;br /&gt;
왼쪽으로 비트가 밀려서 자료형 범위를 초과하게 되면 값이 사라지게 됩니다.&lt;br /&gt;
&lt;br /&gt;
0100 1111 :: 79&lt;br /&gt;
0001 0011 :: 19(결과)&lt;/p&gt;

&lt;p&gt;결과를 보면 알 수 있듯이 왼쪽으로 비트를 1칸 밀 수록 2배 작아집니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-and를-이용한-색상값-마스크&quot;&gt;SHIFT, AND를 이용한 색상값 마스크&lt;/h3&gt;
&lt;p&gt;SHIFT 연산은 컬러값에서 마스크 연산에 사용 됩니다.&lt;br /&gt;
색상은 RGB로 표현하는데 0~255 값으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;RGB 하얀색 색상값을 가진 값은 0xFF(R) FF(G) FF(B)가 됩니다.&lt;br /&gt;
16진수 기준 15는 0xF입니다.&lt;br /&gt;
10진수 255는 16진수로 0xFF가 됩니다.&lt;br /&gt;
FF를 2진수로 표현하면 1111 1111 입니다.&lt;/p&gt;

&lt;p&gt;10진수 65,535는 16진수 0xFFFF가 됩니다.&lt;br /&gt;
10진수 16,777,215는 16진수 0xFFFFFF가 됩니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;0xFFEE11 컬러값에서 RGB중 R을 나타내는 FF 부분을 뽑아 내려면&lt;br /&gt;
오른쪽으로 8칸씩 2번 밀면됩니다. (총 16번)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비트로 표현해보겠습니다.&lt;br /&gt;
0001 0001 :: 11&lt;br /&gt;
1110 1110 :: EE&lt;br /&gt;
1111 1111 :: FF
0xFFEE11 » 16
0xFF&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
처음 8칸을 오른쪽으로 밀면 가장 하위 비트에 속하는 11은 사라지게 됩니다.&lt;br /&gt;
다시 8칸을 오른쪽으로 밀면 하위 비트에 속하는 EE는 사라지게 됩니다.&lt;br /&gt;
색상값을 비트를 밀어서 찾아낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 만약 ? EE 값을 뽑기 위해선 어떤 방법을 취해야할까요 ?&lt;br /&gt;
11은 찾는 값이 아니므로 8칸을 밀어서 버려줍니다.&lt;br /&gt;
0xFFEE 값 중 EE 값을 추출하기 위해서는 0xFF 값과 AND 연산을 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이를 비트로 표현해보겠습니다. 8byte마다 구분은 / 로 하겠습니다.&lt;br /&gt;
1111 1111 / 1110 1110 :: FFEE&lt;br /&gt;
0000 0000 / 1111 1111 :: FF&lt;br /&gt;
0000 0000 / 1110 1110 :: EE(결과)&lt;/p&gt;

&lt;p&gt;지금까지 비트연산과 쓰임세를 알아보는 유익한 시간이었습니다.
&lt;!--
[![standard-readme compliant](https://img.shields.io/badge/readme%20style-standard-brightgreen.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)
--&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="비트" /><category term="bit" /><category term="bitwise" /><category term="비트연산" /><category term="or" /><category term="and" /><category term="not" /><category term="xor" /><category term="shift" /><summary type="html">[C++] 비트 연산 Bitwise</summary></entry><entry><title type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/" rel="alternate" type="text/html" title="[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)" /><published>2020-05-02T00:00:00+09:00</published><updated>2020-05-02T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage%20%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94%20%EB%B9%84%ED%8A%B8%EB%A7%B5%20%EB%A7%8C%EB%93%A4%EA%B8%B0-2</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;비어있는 비트맵 만들기 1편: &lt;a href=&quot;/../프로그래밍/mfc/cimage/CImage-비어있는-비트맵-만들기-1&quot; target=&quot;_blank&quot;&gt;비어있는 비트맵 만들기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;비어있는 비트맵을 만들었으니 큰 이미지에서 일부만 잘라서 화면에 출력해보겠습니다.&lt;br /&gt;
BitBlt() 함수를 이용하여 이미지를 그리고 그릴 이미지의 범위를 지정해주면 됩니다.&lt;/p&gt;

&lt;p&gt;실습에서 사용된 이미지 파일은 bmp 파일(24 bit)입니다.&lt;/p&gt;

&lt;h2 id=&quot;조각-이미지-만들기&quot;&gt;조각 이미지 만들기&lt;/h2&gt;
&lt;p&gt;조각 이미지를 만드는 방법은 큰 이미지를 로드한 후 비어있는 비트맵에 그림을 그려주는 것입니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 파일이나 리소스ID를 이용해 큰 이미지(bmpImage)를 로드합니다.&lt;br /&gt;
비어있는 비트맵(sliceBmpImage)을 150x150 사이즈로 만들고&lt;br /&gt;
bmpImage가 가지고 있는 이미지를 sliceBmpImage DC에 복사(BitBlt) 합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비트맵을 만들 때 주의할 점은 어떤 이미지를 잘라내어 담을지 결정해두고&lt;br /&gt;
해당 이미지와 화소당 비트(&lt;a href=&quot;https://ko.wikipedia.org/wiki/색_깊이&quot;&gt;BPP&lt;/a&gt;)를 똑같이 만들어줘야 합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;DC를 가져올 때에는 BitBlt() 함수는 HDC 타입 데이터를 요구하기 때문에&lt;br /&gt;
CImage 클래스에서 제공하는 GetDC() 함수를 사용합니다.&lt;br /&gt;
GetDC() 함수를 사용했을 경우 반드시 ReleaseDC()를 해줘서 사용한 리소스를 돌려주어야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 sliceBmpImage가 가지고 있는 이미지를 화면 DC에다가 그려줍니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;OnPaintDC&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AfxGetInstanceHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDB_BITMAP1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ㅖ&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 사용자는 그림에서 250, 250 위치부터 150x150 크기 조각 이미지를 비어있는 비트맵에 0,0 위치에 복사&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 사용자는 뷰에서 40, 15가 떨어진 위치에서 150x150 크기의 조각 이미지를 화면에 출력하고 싶습니다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;f-큰-이미지에서-조각-이미지-출력하는-함수&quot;&gt;[F] 큰 이미지에서 조각 이미지 출력하는 함수&lt;/h2&gt;
&lt;figcaption&gt;이미지를 잘라내는 작업은 빠르지 않습니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SliceDraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SliceDraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//SliceDraw(dc, 40, 15, CSize(300, 300), bmpImage, 250, 250);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;f-큰-이미지에서-조각-이미지의-cimage-타입-변수를-반환하는-함수&quot;&gt;[F] 큰 이미지에서 조각 이미지의 CImage 타입 변수를 반환하는 함수&lt;/h2&gt;
&lt;figcaption&gt;이미지를 잘라내는 작업은 빠르지 않습니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//CImage bmpImage;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//bmpImage.LoadFromResource(AfxGetInstanceHandle(), IDB_BITMAP1);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//CImage *sliceMyImage = getSliceImage(bmpImage, CSize(200, 200), 50, 50);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage-&amp;gt;BitBlt(dc.m_hDC, CPoint(100, 100), SRCCOPY);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//bmpImage.Detach();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage-&amp;gt;Detach();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//delete sliceMyImage;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage = nullptr;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;간단히 실습한 과정을 정리해보았습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;조각 이미지 크기를 입력하여 비어있는 비트맵을 만들고 큰 이미지를 일부 복사해야합니다.
    &lt;ul&gt;
      &lt;li&gt;비어있는 비트맵과 큰 이미지의 화소당 비트(&lt;a href=&quot;https://ko.wikipedia.org/wiki/색_깊이&quot;&gt;BPP&lt;/a&gt;)는 반드시 동일해야합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이미지를 복사할 때 복사를 시작할 위치 및 복사할 이미지 크기를 적어야합니다.&lt;/li&gt;
  &lt;li&gt;BitBlt() 함수를 이용하여 비어있는 비트맵에 큰 이미지를 복사합니다.
    &lt;ul&gt;
      &lt;li&gt;복사할 대상DC 매개변수가 HDC를 요구하므로
        &lt;ul&gt;
          &lt;li&gt;GetDC() 함수를 이용하여 CImage가 가지고 있는 이미지 DC로 접근할 수 있습니다.&lt;/li&gt;
          &lt;li&gt;GetDC() 함수를 사용한 경우 빠르게 ReleaseDC() 함수를 사용하여 사용한 리소스를 되돌려 줍니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;View에 출력할 조각 이미지를 출력할 위치와 출력할 조각 이미지의 크기를 입력합니다.&lt;/li&gt;
  &lt;li&gt;마지막으로 출력된 그림을 보고 흐뭇하게 웃습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/sliceBmpImage.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="CImage" /><category term="이미지" /><category term="Image" /><category term="비트맵" /><category term="Bitmap" /><category term="출력" /><category term="BitBlt" /><category term="부분 이미지" /><category term="SliceDraw" /><category term="getSliceImage" /><summary type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)</summary></entry></feed>