<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://tars-c.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tars-c.github.io/" rel="alternate" type="text/html" /><updated>2020-05-05T15:26:41+09:00</updated><id>https://tars-c.github.io/feed.xml</id><title type="html">타스의 개발 블로그</title><subtitle>기록은 지식이라고 믿는 자의 블로그</subtitle><author><name>타스 (TARS-C)</name></author><entry><title type="html">[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%95%EB%B3%B4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EC%A0%95%EB%B3%B4%20%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%A0%95%EB%B3%B4-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;프로그램 개발 시 이미지의 크기 정보 및 가지고 있는 정보가 필요할 때가 있습니다.&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CImage 클래스에서 제공하는 함수&lt;/code&gt;에서 이미지 정보를 가져오는 함수를 알아봅니다.&lt;/p&gt;

&lt;h2 id=&quot;이미지-정보-가져오기&quot;&gt;이미지 정보 가져오기&lt;/h2&gt;

&lt;h3 id=&quot;가로폭-width-가져오기&quot;&gt;가로(폭, Width) 가져오기&lt;/h3&gt;
&lt;p&gt;가로 폭 정보를 제공해주는 함수는 GetWidth() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgWidth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;세로높이-height-가져오기&quot;&gt;세로(높이, Height) 가져오기&lt;/h3&gt;
&lt;p&gt;세로 높이 정보를 제공해주는 함수는 GetHeight() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgHeight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;pixel당-비트-수bpp-가져오기&quot;&gt;Pixel당 비트 수(BPP) 가져오기&lt;/h3&gt;
&lt;p&gt;Pixel당 비트 수 정보를 제공해주는 함수는 GetBPP() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;x-y-위치의-픽셀-주소-및-컬러값-가져오기&quot;&gt;x, y 위치의 픽셀 주소 및 컬러값 가져오기&lt;/h3&gt;
&lt;p&gt;(x, y) 위치의 픽셀 주소값 제공해주는 함수는 GetPixelAddress() 입니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;COLORREF&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetPixelAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imgBPP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>타스 (TARS-C)</name></author><category term="이미지" /><category term="Image" /><category term="정보" /><category term="GetWidth" /><category term="GetHeight" /><category term="GetBPP" /><category term="GetPixelAddress" /><category term="가로" /><category term="Width" /><category term="세로" /><category term="Height" /><category term="화소당비트" /><category term="BPP" /><category term="픽셀" /><category term="Pixel" /><category term="주소" /><category term="Address" /><summary type="html">[MFC] CImage : 이미지 정보 가져오기 (크기, BPP, Pixel)</summary></entry><entry><title type="html">[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/%EB%B9%A0%EB%A5%B8-%EB%A1%9C%EA%B7%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%86%8C%EA%B0%9C/" rel="alternate" type="text/html" title="[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/%EB%B9%A0%EB%A5%B8%20%EB%A1%9C%EA%B7%B8%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%20%EC%86%8C%EA%B0%9C</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/%EB%B9%A0%EB%A5%B8-%EB%A1%9C%EA%B7%B8-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%86%8C%EA%B0%9C/">&lt;p&gt;C++ 개발자방에서 한분이 라이브러리를 소개시켜주었습니다.&lt;br /&gt;
벤치마크 성능을 보니까 빠르고 좋아보여 공유하고자 합니다.&lt;br /&gt;
자세한건 아래 링크를 참고해주시기 바랍니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gabime/spdlog&quot; target=&quot;_blank&quot;&gt;Project: spldog Library Repository&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://travis-ci.org/gabime/spdlog&quot;&gt;&lt;img src=&quot;https://travis-ci.org/gabime/spdlog.svg?branch=v1.x&quot; alt=&quot;Build Status&quot; /&gt;&lt;/a&gt;   &lt;a href=&quot;https://ci.appveyor.com/project/gabime/spdlog&quot;&gt;&lt;img src=&quot;https://ci.appveyor.com/api/projects/status/d2jnxclg20vd0o50?svg=true&quot; alt=&quot;Build status&quot; /&gt;&lt;/a&gt;   &lt;a href=&quot;https://github.com/gabime/spdlog/releases/latest&quot;&gt;&lt;img src=&quot;https://img.shields.io/github/release/gabime/spdlog.svg&quot; alt=&quot;Release&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지원하는 플랫폼
    &lt;ul&gt;
      &lt;li&gt;Android&lt;/li&gt;
      &lt;li&gt;Linux (FreeBSD, OpenBSD, Solaris, AIX)&lt;/li&gt;
      &lt;li&gt;macOS (clang 3.5 later)&lt;/li&gt;
      &lt;li&gt;Windows (msvc 2013 later, cygwin)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지원하는 설치 및 패키지 매니저
    &lt;ul&gt;
      &lt;li&gt;cmake&lt;/li&gt;
      &lt;li&gt;Homebrew&lt;/li&gt;
      &lt;li&gt;MacPorts&lt;/li&gt;
      &lt;li&gt;FreeBSD&lt;/li&gt;
      &lt;li&gt;Fedora&lt;/li&gt;
      &lt;li&gt;Gentoo&lt;/li&gt;
      &lt;li&gt;Arch Linux&lt;/li&gt;
      &lt;li&gt;vcpkg&lt;/li&gt;
      &lt;li&gt;conan&lt;/li&gt;
      &lt;li&gt;conda&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
  이 라이브러리는 JetBrains 라이센스 기증을 받아 제작되었습니다.&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="spdlog" /><category term="로그" /><category term="Logging" /><category term="Log" /><category term="라이브러리" /><category term="Library" /><summary type="html">[C++][소개] 빠른 로깅(Logging) 라이브러리 : spdlog</summary></entry><entry><title type="html">[MFC] Bitmap Format (DIB, DDB) : 설명</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%8F%AC%EB%A7%B7-(DIB,-DDB)/" rel="alternate" type="text/html" title="[MFC] Bitmap Format (DIB, DDB) : 설명" /><published>2020-05-05T00:00:00+09:00</published><updated>2020-05-05T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80%20%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94%20%EB%B9%84%ED%8A%B8%EB%A7%B5%20%ED%8F%AC%EB%A7%B7%20(DIB,%20DDB)</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Windows%EA%B0%80-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%8F%AC%EB%A7%B7-(DIB,-DDB)/">&lt;ul&gt;
  &lt;li&gt;Windows에서 비트맵은 총 2가지 포맷을 지원합니다.
    &lt;ul&gt;
      &lt;li&gt;DDB(Device Dependent Bitmap)&lt;/li&gt;
      &lt;li&gt;DIB(Device Indepedent Bitmap)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ddb-과거-화려했던-스타&quot;&gt;DDB (과거 화려했던 스타)&lt;/h2&gt;
&lt;p&gt;Windows 3.0 이전 버전에서 사용되던 포맷 방식입니다.&lt;br /&gt;
하지만 오늘날에서도 쓸 수 있습니다.&lt;br /&gt;
DC에 SelectObject() 할 수 있는 포맷&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(개발자라면 DDB도 알아야합니다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;장치에 의존 및 독립되지 않은 비트맵을 의미합니다.&lt;br /&gt;
과거 비트맵을 출력했던 방식에서 사용됩니다.&lt;/p&gt;

&lt;p&gt;장치에 독립되지 않고 의존적이므로 내 장치가 흑백 장치라면&lt;br /&gt;
어떤 이미지든 흑백으로 밖에 이미지를 볼 수 밖에 없는 것입니다.&lt;/p&gt;

&lt;p&gt;DIB의 장점은 연산할 때 속도가 빠릅니다.&lt;br /&gt;
단점은 컬러 비트맵을 출력할 수 있는 장치에서는 흑백 비트맵을 출력할 수 없습니다.&lt;/p&gt;

&lt;p&gt;Createbitmap() 함수를 사용하여 DDB 비트맵을 생성할 수 있습니다.&lt;br /&gt;
장치에 독립적이므로 비트맵 헤더 구조가 간단하게 이루어져있습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tagBITMAP&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LONG&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmWidthBytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmPlanes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WORD&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmBitsPixel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;  &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LPVOID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BITMAP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;dib-지금도-핫한-스타&quot;&gt;DIB (지금도 핫한 스타)&lt;/h2&gt;
&lt;p&gt;Windows 3.0 버전부터 사용되온 포맷 방식입니다.&lt;br /&gt;
지금까지도 흔하게 쓰고 있는 비트맵입니다.&lt;/p&gt;

&lt;p&gt;비트맵 파일을 저장될 때에도 DIB 포맷을 사용합니다.&lt;br /&gt;
DC에 SelectObject() 할 수 없는 포맷&lt;/p&gt;

&lt;p&gt;장치랑 상관없이 어느장치에나 색상을 완벽하게 출력할 수 있습니다.&lt;br /&gt;
활용도가 DIB보단 훨씬 넓고 광범위합니다.&lt;br /&gt;
전체적으로 파일이 가지고 있는 데이터가 크므로 연산 속도가 느립니다.&lt;/p&gt;

&lt;p&gt;흑백만 출력할 수 있는 장치에서&lt;br /&gt;
파일 자체가 비트맵 정보를 가지고 있기 때문에 컬러로 출력할 수 있습니다.&lt;/p&gt;

&lt;p&gt;CreateCompatibleBitmap() 함수를 사용하여 DIB 비트맵을 변환 및 생성할 수 있습니다.&lt;br /&gt;
색상정보를 가지고 있기 때문에 비트맵 헤더의 크기는 DIB 비트맵 헤더보다 큽니다.&lt;br /&gt;
헤더는 BITMAPFILEHEADER, BITMAPINFOHEADER 로 구성되어 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DDB
    &lt;ul&gt;
      &lt;li&gt;과거 화려했던 스타 (Windows 3.0 이전 버전, 지금까지도 사용할 수 있음)&lt;/li&gt;
      &lt;li&gt;장치에 묶여있음(종송적)&lt;/li&gt;
      &lt;li&gt;장치가 지원하는 색상만 출력할 수 있음&lt;/li&gt;
      &lt;li&gt;비트맵 헤더가 매우 단순하고 가벼움&lt;/li&gt;
      &lt;li&gt;연산 속도는 빠름&lt;/li&gt;
      &lt;li&gt;생성 및 파괴 오버헤드 적음&lt;/li&gt;
      &lt;li&gt;DC에 SelectObject() 가능 &lt;del&gt;&lt;strong&gt;(Only You)&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;Createbitmap() 함수를 이용한 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DIB
    &lt;ul&gt;
      &lt;li&gt;지금도 핫한 스타 (WIndows 3.0 버전에서부터 사용됨)&lt;/li&gt;
      &lt;li&gt;장치랑 상관없이 자유로움 &lt;del&gt;&lt;strong&gt;(장치에서의 해방이다~)&lt;/strong&gt;&lt;/del&gt;&lt;/li&gt;
      &lt;li&gt;장치가 지원하지 않지만 다른 색상도 출력할 수 있음&lt;/li&gt;
      &lt;li&gt;색상 정보를 가지고 있으므로 비트맵 헤더가 복잡하고 큼&lt;/li&gt;
      &lt;li&gt;연산속도는 DDB보다 느림&lt;/li&gt;
      &lt;li&gt;생성 및 파괴는 DIB보다 비효율적&lt;/li&gt;
      &lt;li&gt;DC에 SelectObject() 불가능! (내부 변환과정 거쳐야함)&lt;/li&gt;
      &lt;li&gt;CreateCompatibleBitmap() 함수를 이용한 변환 및 생성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>타스 (TARS-C)</name></author><category term="DIB" /><category term="DDB" /><category term="장치" /><category term="Device" /><category term="비트맵" /><category term="Bitmap" /><category term="포맷" /><category term="Format" /><category term="이미지포맷" /><category term="ImageFormat" /><summary type="html">[MFC] Bitmap Format (DIB, DDB) : 설명</summary></entry><entry><title type="html">[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%97%A4%EB%8D%94-%EC%9D%BD%EC%96%B4%EC%84%9C-%ED%8C%8C%EC%9D%BC-%ED%81%AC%EA%B8%B0-%EC%95%8C%EC%95%84%EC%98%A4%EA%B8%B0/" rel="alternate" type="text/html" title="[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기" /><published>2020-05-04T00:00:00+09:00</published><updated>2020-05-04T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%B9%84%ED%8A%B8%EB%A7%B5%20%ED%97%A4%EB%8D%94%20%EC%9D%BD%EC%96%B4%EC%84%9C%20%ED%8C%8C%EC%9D%BC%20%ED%81%AC%EA%B8%B0%20%EC%95%8C%EC%95%84%EC%98%A4%EA%B8%B0</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/%EB%B9%84%ED%8A%B8%EB%A7%B5-%ED%97%A4%EB%8D%94-%EC%9D%BD%EC%96%B4%EC%84%9C-%ED%8C%8C%EC%9D%BC-%ED%81%AC%EA%B8%B0-%EC%95%8C%EC%95%84%EC%98%A4%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;비트맵 파일 헤더 중 파일 크기 정보에 해당하는 데이터를 읽어서 파일 크기를 출력합니다.&lt;br /&gt;
비트맵 헤더 시작 위치는 0x0에 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;비트맵-헤더&quot;&gt;비트맵 헤더&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;비트맵 헤더는 총 2가지로 구성되어 있으며 총 54byte 크기를 차지하고 있습니다.
    &lt;ul&gt;
      &lt;li&gt;BITMAPFILEHEADER (14byte)&lt;/li&gt;
      &lt;li&gt;BITMAPINFOHEADER (40byte)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일 크기 정보가 명시된 헤더는 Biamp File Header(BITMAPFILEHEADER) 입니다.&lt;br /&gt;
아래 그림은 비트맵 파일 전체 구조입니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/bmpheader.jpg&quot; alt=&quot;img1&quot; /&gt;
파일 크기 정보를 구해오기 위해 중요하게 봐야할 것은 FileSize 입니다.&lt;br /&gt;
파일 크기 정보를 가진 데이터는 4Byte이며,&lt;br /&gt;
시작위치는 2번째 위치에 있습니다. (start based 0)&lt;/p&gt;

&lt;p&gt;비트맵 헤더에서 파일 크기 정보를 가지고 있는 부분을 읽어서 출력하면 됩니다.&lt;br /&gt;
주의할 점은 일반적으로 메모리를 읽어들이는 방식은 BigEndian입니다.&lt;br /&gt;
하지만 헤더의 데이터는 LittleEndian 방식으로 되어있으며 변환작업이 필요합니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(변환 작업은 그냥 비트를 밀면 됩니다)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;파일을 Open 후 seekg() 함수를 사용해서 파일을 읽어들이는 위치를 지정합니다.&lt;br /&gt;
파일 크기 정보를 얻으려면 2번째 위치부터 4byte 읽어옵니다.&lt;/p&gt;

&lt;p&gt;LittleEndian 방식의 데이터를 비트 연산자를 이용해 비트를 밀어서 Bigendian 데이터로 출력합니다.&lt;/p&gt;

&lt;h2 id=&quot;f비트맵-파일-크기를-얻어오는-함수&quot;&gt;[F]비트맵 파일 크기를 얻어오는 함수&lt;/h2&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBitmapFileSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getBitmapFileSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ifstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;binary&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seekg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ios&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//string filePath = &quot;Desktop/myBmp.bmp&quot;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//getBitmapFileSize(filePath);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/resultbmpfilesize.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/CImage/bmpfilesizeinfo.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="cpp" /><category term="비트맵" /><category term="bitmap" /><category term="bmp" /><category term="header" /><category term="헤더" /><category term="파일크기" /><category term="파일읽기" /><category term="파일 크기 정보" /><category term="BITMAPFILEHEADER" /><category term="BITMAPINFOHEADER" /><summary type="html">[C++] 비트맵 헤더 정보를 읽어 비트맵 파일 크기 구하기</summary></entry><entry><title type="html">[C++] 비트 연산 Bitwise</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/CPP-XOR/" rel="alternate" type="text/html" title="[C++] 비트 연산 Bitwise " /><published>2020-05-03T00:00:00+09:00</published><updated>2020-05-03T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/CPP-XOR</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/c++/CPP-XOR/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;저에게 XOR은 조금 친근하지 못한 연산자였는데&lt;br /&gt;
한가지 쓰임을 알게게 되어 비트 연산 전체를 포스팅하게 되었습니다.&lt;br /&gt;
비트 연산을 한다고 해서 피연산자를 2개 요구하는 연산자들은 결과가 바로 반영되지 않습니다.&lt;br /&gt;
비트 연산도 산술연산자처럼 축약형으로 사용할 수 있습니다. (&amp;amp;=, |=, ^=, «=, »=)&lt;/p&gt;

&lt;p&gt;비트연산은 다른 연산자에 비해 처리 속도가 빠릅니다.&lt;br /&gt;
공부를 할때 숫자를 막 써놔도 비트연산은 눈으로 봐도 잘 들어오지 않습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;화면에 계산기를 켜두고 하나씩 실습해보면 누구나 쉽게 터득할 수 있습니다.&lt;br /&gt;
비트연산 관련 프로그래밍 시 계산기를 이용하면 빠르게 작업을 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;예시에서 사용되는 타입 크기는 임의 크기인 1byte입니다.&lt;br /&gt;
기본 int 타입 크기는 x86 환경에서 4byte인 점을 주의하셔야 합니다.&lt;br /&gt;
(자료형의 크기가 클 수록 비트가 복잡하므로 나머지 3byte는 명시 안함)&lt;/p&gt;

&lt;p&gt;비트는 10진수가 가진 값을 2의 n승 꼴로 표현할 수 있습니다.&lt;br /&gt;
10진수와 관계지어 비트가 차지하고 있는 위치에 대해 알아야합니다.&lt;br /&gt;
아래에 비트연산을 이해하기 위해서는 다음과 같은 개념을 아셔야 합니다.&lt;br /&gt;
첫번째 비트: 2의 0승 = 1&lt;br /&gt;
두번째 비트: 2의 1승 = 2&lt;br /&gt;
세번째 비트: 2의 3승 = 4&lt;br /&gt;
네번째 비트: 2의 4승 = 8&lt;br /&gt;
다섯번째 비트: 2의 5승 = 16&lt;/p&gt;

&lt;p&gt;비트가 0000 1111 로 구성되어 있으면&lt;br /&gt;
10진수 값은  15가 됩니다. (1 + 2 + 4 + 8)&lt;/p&gt;

&lt;h2 id=&quot;or-연산&quot;&gt;OR 연산&lt;/h2&gt;
&lt;p&gt;OR 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;OR 비트연산은 두개의 비트 중 하나만 1이면 결과가 참(1)이 되는 것을 의미합니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 식에서 A와 B는 OR 연산자(|)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0000 0010 :: 2&lt;br /&gt;
0000 0111 :: 7(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 오른쪽이 첫번째 비트)&lt;br /&gt;
(5의 1번째 비트 1 | 2의 1번째 비트 0) 연산 = 1&lt;br /&gt;
(5의 2번째 비트 0 | 2의 2번째 비트 1) 연산 = 1&lt;br /&gt;
(5의 3번째 비트 1 | 2의 3번째 비트 0) 연산 = 1&lt;br /&gt;
나머지 비트 모두 0&lt;br /&gt;
연산 결과: 0000 0111 (10진수: 7)이 나오게 됩니다.&lt;/p&gt;

&lt;p&gt;또, OR 연산은 두개의 피연산자가 가진 값에 해당하는 비트가 중복되지 않는 선에서 더하기에도 쓰인다는 겁니다.&lt;br /&gt;
5와 2를 OR 비트 연산했는데 결과값이 7이 나왔죠 ? &lt;del&gt;&lt;strong&gt;(어이쿠! 더해졌네?)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
반대로 비트가 중복되는 경우를 보자면&lt;br /&gt;
1과 3을 OR 연산하면 결과가 3이 나오게 되고 덧셈을 못하는 슬픔을 겪게 될 수도 있습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;덧셈방식을 이용하여 특정 속상값을 부여할 수도 있습니다.&lt;br /&gt;
0000 0000 비어 있는 비트가 있을 때&lt;br /&gt;
0000 0001 10진수 1을 사용하여 OR 연산으로 1비트를 채워줄 수 있고&lt;br /&gt;
0000 0010 두번째 비트도 10진수 2를 사용하여 1을 채워줄 수 있습니다.&lt;br /&gt;
OR 비트 연산을 이용하면 값에 여러가지 속성값을 부여할 수 있습니다. (Flag 연산)&lt;/p&gt;

&lt;p&gt;WINAPI, MFC에서도 스타일처럼 여러개의 속성을 적용시킬 수 있을 때&lt;br /&gt;
OR 비트 연산을 이용해 여러개의 속성을 부여하는 방식을 다음과 같이 사용합됩니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;style&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_VISIBLE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_CHILD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WS_THINFRAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;and-연산&quot;&gt;AND 연산&lt;/h2&gt;
&lt;p&gt;AND 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;AND 비트 연산은 두개의 비트 중 둘다 1이어야 결과가 참(1)이 되는 것을 의미합니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위 식에서 A와 B는 AND 연산자(&amp;amp;)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0000 0011 :: 3&lt;br /&gt;
0000 0001 :: 1(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 왼쪽이 첫번째 비트)&lt;br /&gt;
(5의 1번째 비트 1 &amp;amp; 3의 1번째 비트 1) 연산 = 1&lt;br /&gt;
(5의 2번째 비트 0 &amp;amp; 3의 2번째 비트 1) 연산 = 0&lt;br /&gt;
(5의 3번째 비트 1 &amp;amp; 3의 3번째 비트 0) 연산 = 0&lt;br /&gt;
나머지 비트 모두 0&lt;br /&gt;
연산 결과: 0000 0001 (10진수: 1)&lt;/p&gt;

&lt;p&gt;또, AND 연산자(&amp;amp;)를 이용해 속성값을 가지고 있는지에 대해 찾을 수도 있습니다.&lt;br /&gt;
말로 설명하는 것보다 코드로 설명드리겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x02&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;levelPermission&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//invalid permission&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// success&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;속성에서 관리자의 권한값은 4입니다.&lt;br /&gt;
사용자가 가지고 있는 권한은 유저(1) + 관리자(4)이므로 권한값은 즉, 5입니다.&lt;br /&gt;
4와 5를 AND 연산자(&amp;amp;)를 이용해 비트연산을 진행합니다.&lt;br /&gt;
0000 0101 (10진수: 5)&lt;br /&gt;
0000 0100 (10진수: 4)&lt;/p&gt;

&lt;p&gt;두 수가 가진 비트 중 3번째 비트가 모두 1이므로 AND 연산 결과는 1이 됩니다.&lt;br /&gt;
&lt;strong&gt;(전 개인적으로 접근 불가나 오류 발생하는 코드가 위에 있으면 좋더라구요..)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;속성 값이 가진 비트를 뒤집어서 &amp;amp; 연산하면 사용자가 가지고 있는 권한을 뺏을 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;myPermission&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ePermission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;not-연산&quot;&gt;NOT 연산&lt;/h2&gt;
&lt;p&gt;NOT 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 1개가 필요합니다.&lt;/p&gt;

&lt;p&gt;NOT 비트연산은 비트를 모두 뒤집어버리는 것입니다.&lt;br /&gt;
0을 1로, 1을 0으로 바꾼다 생각하시면 됩니다.&lt;/p&gt;

&lt;p&gt;생각보다 쓰임이 적다고 생각되는 연산자였습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;알고리즈머 YunGoon님께 관련된 쓰임세를 몇가지 알아왔습니다. 감사합니다.&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
쓰임1과 쓰임2에 해당하는 - 는 부호 연산자입니다. &lt;del&gt;(빼기가 아닙니다)&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;-n은-n1-꼴로-사용될-수-있다&quot;&gt;-~n은 n+1 꼴로 사용될 수 있다&lt;/h3&gt;
&lt;p&gt;10진수 4를 비트로 표현하면 0000 0100 입니다.&lt;br /&gt;
이를 NOT 연산하여 비트를 뒤집어 보면 1111 1011이 됩니다.&lt;br /&gt;
그리고 맨 앞에 있는 -로 부호를 반전시켜주면 비트는 0000 0101이 되고 5가 되는 것입니다.&lt;br /&gt;
부호를 반전시킬 때는 NOT 연산으로 비트를 모두 뒤집고 맨 오른쪽 비트에 1을 더하면 됩니다.&lt;br /&gt;
1을 더하는 이유는 보수의 변환과정에서 1을 더했기 때문에 다시 더해주는 것입니다.&lt;/p&gt;

&lt;p&gt;0000 0100 (10진수: 4)&lt;br /&gt;
1111 1011 (NOT) (10진수: -5)&lt;br /&gt;
0000 0101 (부호반전) (10진수: 5)&lt;/p&gt;

&lt;h3 id=&quot;-n은-n-1-꼴로-사용할-수-있다&quot;&gt;~-n은 n-1 꼴로 사용할 수 있다&lt;/h3&gt;
&lt;p&gt;쓰임1과 매우 비슷합니다. 이번엔 7로 해보겠습니다.&lt;br /&gt;
10진수 7을 비트로 표현하면 0000 0111 입니다.&lt;br /&gt;
2의 보수로 만드는 방법을 이용해 -7로 만들어주는 것입니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;음수를 표현할 때 2의 보수를 사용하는데 변환과정을 아주 간략하게 설명드리면&lt;br /&gt;
양수 7이 가진 비트를 뒤집고 맨 오른쪽 비트에 1을 더해줍니다.&lt;br /&gt;
-7에서 NOT 연산을 하여 비트를 뒤집어주면 6이 됩니다.&lt;/p&gt;

&lt;p&gt;0000 0111 (10진수: 7)&lt;br /&gt;
1111 1001 (부호반전) (10진수: -7)&lt;br /&gt;
0000 0110 (NOT) (10진수: 6)&lt;/p&gt;

&lt;h3 id=&quot;eof라면-루프-탈출에-사용할-수-있다&quot;&gt;EOF라면 루프 탈출에 사용할 수 있다&lt;/h3&gt;
&lt;p&gt;수 많은 컴파일러가 EOF를 -1로 정의합니다.&lt;br /&gt;
-1 값을 가지고 반복문을 사용한다면 NOT 연산을 통해 비트를 뒤집습니다.&lt;br /&gt;
-1 값이 0 으로 변경되고 if, while, for 같은 조건문에서 활용될 수 있습니다.&lt;/p&gt;

&lt;p&gt;1111 1111 (10진수: -1)&lt;br /&gt;
0000 0000 (NOT) (10진수: 0)&lt;/p&gt;

&lt;p&gt;이는 while(~scanf()) { } 처럼 응용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;xor-연산&quot;&gt;XOR 연산&lt;/h2&gt;
&lt;p&gt;XOR 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;/p&gt;

&lt;p&gt;XOR 비트연산은 OR과 비슷하면서도 전혀 다릅니다.&lt;br /&gt;
두 수중 비트를 하나씩 비교하여 둘다 1이거나 0일 떄 0을 반환합니다.&lt;br /&gt;
서로 같은 값이면 0, 서로 같지 않으면 1을 반환한다고 생가하시면 됩니다.&lt;br /&gt;
쉽게 이해하기 위해 변수를 만들어 연산자를 이용해 계산을 해보고 과정을 적어보겠습니다.&lt;/p&gt;

&lt;p&gt;숫자 7과 3을 예시로 들어보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ans&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 식에서 A와 B는 XOR 연산자(^)를 이용해 비트 연산을 진행하게 됩니다.&lt;br /&gt;
0000 0111 :: 7&lt;br /&gt;
0000 0011 :: 3&lt;br /&gt;
0000 0100 :: 4(결과)&lt;/p&gt;

&lt;p&gt;연산하는 과정을 하나씩 살펴보자면, (맨 왼쪽이 첫번째 비트)&lt;br /&gt;
(7의 1번째 비트 1 &amp;amp; 3의 1번째 비트 1) 연산 = 0&lt;br /&gt;
(7의 2번째 비트 1 &amp;amp; 3의 2번째 비트 1) 연산 = 0&lt;br /&gt;
(7의 3번째 비트 1 &amp;amp; 3의 3번째 비트 0) 연산 = 1&lt;br /&gt;
나머지 비트 모두 0 또는 1로 같으므로 0&lt;/p&gt;

&lt;p&gt;XOR은 알면 알 수록 신기한 녀석입니다. &lt;del&gt;&lt;strong&gt;(누가 발견한거지?)&lt;/strong&gt;&lt;/del&gt;&lt;br /&gt;
XOR은 이미지 연산이나 교체 알고리즘에 사용됩니다.&lt;br /&gt;
우연히 알파벳을 빠르게 교체하는 문제를 풀면서 새로운 사용 방법을 알게되었습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;이 방법도 알고리즈머 YunGoon님께서 알려주셨습니다. (깊게 생각했으면 스스로 알았을까?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/CPP/bitwise.png&quot; alt=&quot;img1&quot; /&gt;&lt;br /&gt;
위 그림처럼 10진수 32는 비트를 1개만 가지고 있습니다.&lt;br /&gt;
반대로 31은 32가 가지고 있는 비트를 제외한 나머지 하위 비트를 모두 가지고 있습니다.&lt;br /&gt;
&lt;del&gt;&lt;strong&gt;(이미 알고있는 정보인데도 뭔가 다시 깨달은 느낌이랄까요 ?)&lt;/strong&gt;&lt;/del&gt;&lt;/p&gt;

&lt;h3 id=&quot;비트가-가득찬-경우&quot;&gt;비트가 가득찬 경우&lt;/h3&gt;
&lt;p&gt;10진수 31과 5를 XOR 연산해보겠습니다.&lt;br /&gt;
0001 1111 :: 31&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0001 1010 :: 26(결과)&lt;/p&gt;

&lt;p&gt;자세한 연산과정은 생략하겠습니다.&lt;br /&gt;
재밌는 사실은 31에서 5를 뺀 값인 26이 나온다는 겁니다.&lt;br /&gt;
주의할 점은 31과 31을 연산하면 0이 나오니 주의해야합니다.&lt;/p&gt;

&lt;h3 id=&quot;비트가-비어-있는-경우&quot;&gt;비트가 비어 있는 경우&lt;/h3&gt;
&lt;p&gt;10진수 32와 5를 XOR 연산해보겠습니다.&lt;br /&gt;
0010 0000 :: 32&lt;br /&gt;
0000 0101 :: 5&lt;br /&gt;
0010 0101 :: 37&lt;/p&gt;

&lt;p&gt;자세한 연산과정은 생략하겠습니다.&lt;br /&gt;
재밌는 사실은 32에서 5를 더한 값인 37이 나온다는 겁니다.&lt;br /&gt;
32가 가지고 있는 비트 중 연산하려는 5의 비트가 비어있는 경우 덧셈을 하게 됩니다.&lt;br /&gt;
&lt;br /&gt;
위 방식을 응용한다면 영어 대소문자를 변환하는 작업에 처리속도를 향상시킬 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;shift-연산&quot;&gt;SHIFT 연산&lt;/h2&gt;
&lt;p&gt;SHIFT 비트 연산자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;, &amp;gt;&amp;gt;&lt;/code&gt; 입니다.&lt;br /&gt;
피연산자는 2개가 필요합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;왼쪽 피연산자에는 비트를 조작할 데이터를 적고&lt;br /&gt;
오른쪽 피연산자에는 몇칸을 밀 것인지에 대해 적습니다.&lt;/p&gt;

&lt;p&gt;SHIFT 연산은 비트를 오른쪽 혹은 왼쪽으로 이동할 때 사용합니다.&lt;br /&gt;
왼쪽으로 비트가 밀려서 범위를 초과하면 값이 사라지게 됩니다.&lt;/p&gt;

&lt;p&gt;양수는 최상위 부호비트가 0이므로 어떻게 밀어도 상관이 없습니다.&lt;br /&gt;
음수인 경우에 SHIFT 연산할 경우 최상위 비트(MSB, 부호비트)도 같이 밀리기 때문에 주의해야합니다.&lt;/p&gt;

&lt;p&gt;오른쪽으로 « 밀어서 범위 초과로 값이 이상한 경우 오버플로우(overflow)&lt;br /&gt;
왼쪽으로 » 밀어서 범위 초과로 값이 이상한 경우 언더플로우(underflow)라 합니다.&lt;br /&gt;
SHIFT 연산은 단독으로 사용되기보다 | 및 &amp;amp; 연산과 함께 사용되는 편입니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-오른쪽으로-시프트&quot;&gt;SHIFT « (오른쪽으로 시프트)&lt;/h3&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;31 이 가지고 있는 전체 비트를 오른쪽으로 1칸 밀게 됩니다.&lt;br /&gt;
오른쪽으로 비트가 밀리면 빈자리는 0으로 채워집니다.&lt;/p&gt;

&lt;p&gt;0001 1111 :: 31&lt;br /&gt;
0011 1110 :: 62(결과)&lt;br /&gt;
결과를 보면 알 수 있듯이 오른쪽으로 비트를 1칸 밀 수록 2배 커집니다.&lt;br /&gt;
&lt;br /&gt;
그럼 한번에 2칸을 밀면 2배 커질까요 ? 아닙니다.&lt;br /&gt;
4배 커지게 되는데 이는 오른쪽으로 비트를 밀 수록 2의 n승만큼 커지는 것입니다.&lt;/p&gt;

&lt;p&gt;31 « 3을 계산해봅시다.&lt;br /&gt;
2의 3승은 8 즉, 31x8 값인 248이 결과로 산출됩니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-왼쪽으로-시프트&quot;&gt;SHIFT » (왼쪽으로 시프트)&lt;/h3&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;79&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;79 가 가지고 있는 전체 비트를 왼쪽으로 2칸 밀게 됩니다.&lt;br /&gt;
왼쪽으로 비트가 밀려서 자료형 범위를 초과하게 되면 값이 사라지게 됩니다.&lt;br /&gt;
&lt;br /&gt;
0100 1111 :: 79&lt;br /&gt;
0001 0011 :: 19(결과)&lt;/p&gt;

&lt;p&gt;결과를 보면 알 수 있듯이 왼쪽으로 비트를 1칸 밀 수록 2배 작아집니다.&lt;/p&gt;

&lt;h3 id=&quot;shift-and를-이용한-색상값-마스크&quot;&gt;SHIFT, AND를 이용한 색상값 마스크&lt;/h3&gt;
&lt;p&gt;SHIFT 연산은 컬러값에서 마스크 연산에 사용 됩니다.&lt;br /&gt;
색상은 RGB로 표현하는데 0~255 값으로 구성되어 있습니다.&lt;/p&gt;

&lt;p&gt;RGB 하얀색 색상값을 가진 값은 0xFF(R) FF(G) FF(B)가 됩니다.&lt;br /&gt;
16진수 기준 15는 0xF입니다.&lt;br /&gt;
10진수 255는 16진수로 0xFF가 됩니다.&lt;br /&gt;
FF를 2진수로 표현하면 1111 1111 입니다.&lt;/p&gt;

&lt;p&gt;10진수 65,535는 16진수 0xFFFF가 됩니다.&lt;br /&gt;
10진수 16,777,215는 16진수 0xFFFFFF가 됩니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;0xFFEE11 컬러값에서 RGB중 R을 나타내는 FF 부분을 뽑아 내려면&lt;br /&gt;
오른쪽으로 8칸씩 2번 밀면됩니다. (총 16번)&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비트로 표현해보겠습니다.&lt;br /&gt;
0001 0001 :: 11&lt;br /&gt;
1110 1110 :: EE&lt;br /&gt;
1111 1111 :: FF
0xFFEE11 » 16
0xFF&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
처음 8칸을 오른쪽으로 밀면 가장 하위 비트에 속하는 11은 사라지게 됩니다.&lt;br /&gt;
다시 8칸을 오른쪽으로 밀면 하위 비트에 속하는 EE는 사라지게 됩니다.&lt;br /&gt;
색상값을 비트를 밀어서 찾아낼 수 있습니다.&lt;/p&gt;

&lt;p&gt;그럼 만약 ? EE 값을 뽑기 위해선 어떤 방법을 취해야할까요 ?&lt;br /&gt;
11은 찾는 값이 아니므로 8칸을 밀어서 버려줍니다.&lt;br /&gt;
0xFFEE 값 중 EE 값을 추출하기 위해서는 0xFF 값과 AND 연산을 진행하면 됩니다.&lt;/p&gt;

&lt;p&gt;이를 비트로 표현해보겠습니다. 8byte마다 구분은 / 로 하겠습니다.&lt;br /&gt;
1111 1111 / 1110 1110 :: FFEE&lt;br /&gt;
0000 0000 / 1111 1111 :: FF&lt;br /&gt;
0000 0000 / 1110 1110 :: EE(결과)&lt;/p&gt;

&lt;p&gt;지금까지 비트연산과 쓰임세를 알아보는 유익한 시간이었습니다.
&lt;!--
[![standard-readme compliant](https://img.shields.io/badge/readme%20style-standard-brightgreen.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)
--&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="비트" /><category term="bit" /><category term="bitwise" /><category term="비트연산" /><category term="or" /><category term="and" /><category term="not" /><category term="xor" /><category term="shift" /><summary type="html">[C++] 비트 연산 Bitwise</summary></entry><entry><title type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/" rel="alternate" type="text/html" title="[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)" /><published>2020-05-02T00:00:00+09:00</published><updated>2020-05-02T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage%20-%20%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94%20%EB%B9%84%ED%8A%B8%EB%A7%B5%20%EB%A7%8C%EB%93%A4%EA%B8%B0-2</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-2/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;비어있는 비트맵 만들기 1편: &lt;a href=&quot;/../프로그래밍/mfc/cimage/CImage-비어있는-비트맵-만들기-1&quot; target=&quot;_blank&quot;&gt;비어있는 비트맵 만들기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;비어있는 비트맵을 만들었으니 큰 이미지에서 일부만 잘라서 화면에 출력해보겠습니다.&lt;br /&gt;
BitBlt() 함수를 이용하여 이미지를 그리고 그릴 이미지의 범위를 지정해주면 됩니다.&lt;/p&gt;

&lt;p&gt;실습에서 사용된 이미지 파일은 bmp 파일(24 bit)입니다.&lt;/p&gt;

&lt;h2 id=&quot;조각-이미지-만들기&quot;&gt;조각 이미지 만들기&lt;/h2&gt;
&lt;p&gt;조각 이미지를 만드는 방법은 큰 이미지를 로드한 후 비어있는 비트맵에 그림을 그려주는 것입니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;먼저 파일이나 리소스ID를 이용해 큰 이미지(bmpImage)를 로드합니다.&lt;br /&gt;
비어있는 비트맵(sliceBmpImage)을 150x150 사이즈로 만들고&lt;br /&gt;
bmpImage가 가지고 있는 이미지를 sliceBmpImage DC에 복사(BitBlt) 합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비트맵을 만들 때 주의할 점은 어떤 이미지를 잘라내어 담을지 결정해두고&lt;br /&gt;
해당 이미지와 화소당 비트(&lt;a href=&quot;https://ko.wikipedia.org/wiki/색_깊이&quot;&gt;BPP&lt;/a&gt;)를 똑같이 만들어줘야 합니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;DC를 가져올 때에는 BitBlt() 함수는 HDC 타입 데이터를 요구하기 때문에&lt;br /&gt;
CImage 클래스에서 제공하는 GetDC() 함수를 사용합니다.&lt;br /&gt;
GetDC() 함수를 사용했을 경우 반드시 ReleaseDC()를 해줘서 사용한 리소스를 돌려주어야 합니다.&lt;/p&gt;

&lt;p&gt;마지막으로 sliceBmpImage가 가지고 있는 이미지를 화면 DC에다가 그려줍니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;OnPaintDC&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AfxGetInstanceHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDB_BITMAP1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ㅖ&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 사용자는 그림에서 250, 250 위치부터 150x150 크기 조각 이미지를 비어있는 비트맵에 0,0 위치에 복사&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 사용자는 뷰에서 40, 15가 떨어진 위치에서 150x150 크기의 조각 이미지를 화면에 출력하고 싶습니다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;f-큰-이미지에서-조각-이미지-출력하는-함수&quot;&gt;[F] 큰 이미지에서 조각 이미지 출력하는 함수&lt;/h2&gt;
&lt;figcaption&gt;이미지를 잘라내는 작업은 빠르지 않습니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SliceDraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SliceDraw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;tmpSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//SliceDraw(dc, 40, 15, CSize(300, 300), bmpImage, 250, 250);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;f-큰-이미지에서-조각-이미지의-cimage-타입-변수를-반환하는-함수&quot;&gt;[F] 큰 이미지에서 조각 이미지의 CImage 타입 변수를 반환하는 함수&lt;/h2&gt;
&lt;figcaption&gt;이미지를 잘라내는 작업은 빠르지 않습니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CSize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetBPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReleaseDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resultSliceImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//CImage bmpImage;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//bmpImage.LoadFromResource(AfxGetInstanceHandle(), IDB_BITMAP1);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//CImage *sliceMyImage = getSliceImage(bmpImage, CSize(200, 200), 50, 50);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage-&amp;gt;BitBlt(dc.m_hDC, CPoint(100, 100), SRCCOPY);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//bmpImage.Detach();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage-&amp;gt;Detach();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//delete sliceMyImage;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceMyImage = nullptr;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;간단히 실습한 과정을 정리해보았습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;조각 이미지 크기를 입력하여 비어있는 비트맵을 만들고 큰 이미지를 일부 복사해야합니다.
    &lt;ul&gt;
      &lt;li&gt;비어있는 비트맵과 큰 이미지의 화소당 비트(&lt;a href=&quot;https://ko.wikipedia.org/wiki/색_깊이&quot;&gt;BPP&lt;/a&gt;)는 반드시 동일해야합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이미지를 복사할 때 복사를 시작할 위치 및 복사할 이미지 크기를 적어야합니다.&lt;/li&gt;
  &lt;li&gt;BitBlt() 함수를 이용하여 비어있는 비트맵에 큰 이미지를 복사합니다.
    &lt;ul&gt;
      &lt;li&gt;복사할 대상DC 매개변수가 HDC를 요구하므로
        &lt;ul&gt;
          &lt;li&gt;GetDC() 함수를 이용하여 CImage가 가지고 있는 이미지 DC로 접근할 수 있습니다.&lt;/li&gt;
          &lt;li&gt;GetDC() 함수를 사용한 경우 빠르게 ReleaseDC() 함수를 사용하여 사용한 리소스를 되돌려 줍니다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;View에 출력할 조각 이미지를 출력할 위치와 출력할 조각 이미지의 크기를 입력합니다.&lt;/li&gt;
  &lt;li&gt;마지막으로 출력된 그림을 보고 흐뭇하게 웃습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/sliceBmpImage.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="CImage" /><category term="이미지" /><category term="Image" /><category term="비트맵" /><category term="Bitmap" /><category term="출력" /><category term="BitBlt" /><category term="부분 이미지" /><category term="SliceDraw" /><category term="getSliceImage" /><summary type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-2 (출력)</summary></entry><entry><title type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-1</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/" rel="alternate" type="text/html" title="[MFC][실습] CImage : 비어있는 비트맵 만들기-1" /><published>2020-05-02T00:00:00+09:00</published><updated>2020-05-02T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage%20-%20%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94%20%EB%B9%84%ED%8A%B8%EB%A7%B5%20%EB%A7%8C%EB%93%A4%EA%B8%B0-1</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EB%B9%84%EC%96%B4%EC%9E%88%EB%8A%94-%EB%B9%84%ED%8A%B8%EB%A7%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0-1/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;잠깐만요! 이미 1편을 보셨다구요 ?&lt;br /&gt;
비어있는 비트맵 만들기 2편: &lt;a href=&quot;/../프로그래밍/mfc/cimage/CImage-비어있는-비트맵-만들기-2&quot; target=&quot;_blank&quot;&gt;화면에 조각 이미지 출력하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이미지를 편집할 때 일부 이미지를 잘라야할 때가 있습니다.&lt;br /&gt;
MFC에서는 이미지를 자르기 위해서는 비어있는 비트맵을 만들어야합니다.&lt;br /&gt;
실습에서 사용된 이미지 파일은 bmp 파일(24 bit)입니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 비어있는 비트맵을 만드는 방법에 대해 적어보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;비어있는-비트맵-생성&quot;&gt;비어있는 비트맵 생성&lt;/h2&gt;
&lt;p&gt;비어있는 비트맵을 만드는 방법은 CImage 클래스에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Create() 함수&lt;/code&gt;를 사용합니다.&lt;br /&gt;
비어있는 비트맵을 만들고 BitBlt() 함수를 사용하여 DC에 그림을 그려줄 수 있습니다.&lt;br /&gt;
비어있는 비트맵이 너무 작은 경우 검은 배경이 나타날 수 있으니 크기에 주의해야합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 비어있는 비트맵을 만들 때 필요한 요소는 3가지입니다.
    &lt;ol&gt;
      &lt;li&gt;비트맵 가로 크기(Wdith)&lt;/li&gt;
      &lt;li&gt;비트맵 세로 크기(Height)&lt;/li&gt;
      &lt;li&gt;비트맵 화소 당 비트(&lt;a href=&quot;https://ko.wikipedia.org/wiki/색_깊이&quot; target=&quot;_blank&quot;&gt;BPP&lt;/a&gt;)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;OnPaintDC&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sliceBmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//sliceBmpImage.BitBlt(dc.m_hDC, 40, 15, 300, 300, 0, 0, SRCCOPY);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;150x150 크기의 24bit 비어있는 비트맵을 생성합니다.&lt;br /&gt;
비트맵을 처음 만들게 되면 검은색으로 칠해져 있습니다. (비트맵 색상값이 0으로 채워져 있음)&lt;/p&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/emptyBitmap.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="CImage" /><category term="이미지" /><category term="Image" /><category term="비트맵" /><category term="Bitmap" /><category term="출력" /><category term="BitBlt" /><category term="부분 이미지" /><summary type="html">[MFC][실습] CImage : 비어있는 비트맵 만들기-1</summary></entry><entry><title type="html">[MFC][실습] CImage : 이미지 불러오고 출력하기</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B3%A0-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[MFC][실습] CImage : 이미지 불러오고 출력하기" /><published>2020-05-01T00:00:00+09:00</published><updated>2020-05-01T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage%20-%20%EC%9D%B4%EB%AF%B8%EC%A7%80%20%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B3%A0%20%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/cimage/CImage-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B3%A0-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;MFC는 이미지를 출력할 때 비트맵 변환과정을 거치게 됩니다.&lt;br /&gt;
과거 비트맵을 출력하기 위해서는 복잡한 과정이 있었지만 시간이 지나면서 많은 변화를 겪게되어&lt;br /&gt;
함수 몇가지를 이용하여 이미지를 아주 간단하게 출력할 수 있습니다.&lt;/p&gt;

&lt;p&gt;비트맵(*.bmp) 확장명을 가진 파일을 불러오고 간단히 출력해보도록 하겠습니다.&lt;br /&gt;
OnPaint에서 작업을 했기에 dc 변수의 타입은 OnPaintDC입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;이미지 크기가 큰 경우&lt;/code&gt;에는 초기화되는 시점에 &lt;code class=&quot;highlighter-rouge&quot;&gt;미리 로드&lt;/code&gt;하여&lt;br /&gt;
멤버 및 전역변수로 접근하여 사용하는 것이 좋습니다.&lt;br /&gt;
이 예제에서는 아주 간단하게 알아보는 것이므로 따로 작업하지 않습니다.&lt;/p&gt;

&lt;p&gt;이미지를 단순히 불러오고 화면에 출력하는건 &lt;code class=&quot;highlighter-rouge&quot;&gt;CImage 클래스&lt;/code&gt;가 적합합니다.&lt;br /&gt;
CImage 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;#include &amp;lt;atlimage.h&amp;gt;&lt;/code&gt;를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;비트맵을 로드 하는 방법은 총 2가지가 존재합니다.&lt;/p&gt;

&lt;h2 id=&quot;리소스id를-이용하여-비트맵-출력하기&quot;&gt;리소스ID를 이용하여 비트맵 출력하기&lt;/h2&gt;
&lt;!-- 리소스ID를 이용해 비트맵을 불러올 때에는 CBitmap 클래스에서 제공하는 LoadBitmap\(\) 함수를 이용합니다.
리소스ID를 사용하기 위해서는 리소스뷰에서 비트맵을 추가하거나 삽입해야 합니다.
비트맵 자체에는 DC가 없어서 출력할 수 없습니다.
호환되는 DC를 만들고 비트맵을 담아주도록 합니다. --&gt;
&lt;p&gt;LoadFromResource() 함수를 이용하려면 Resource View에서 비트맵 파일을 추가합니다.&lt;br /&gt;
추가한 비트맵 파일에 리소스ID를 변경 및 부여하도록 합니다.&lt;br /&gt;
비트맵을 불러오려면 CImage 클래스에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadFromResource() 함수&lt;/code&gt;를 이용합니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AfxGetInstanceHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDB_BITMAP1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//bmpImage.Detach();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;비트맵-파일을-이용하여-비트맵-출력하기&quot;&gt;비트맵 파일을 이용하여 비트맵 출력하기&lt;/h2&gt;
&lt;p&gt;비트맵 파일을 불러올 땐 CImage 클래스가 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Load() 함수&lt;/code&gt;를 이용합니다.&lt;br /&gt;
Load() 함수는 JPEG, GIF, BMP 및 PNG 확장명을 가진 이미지 파일을 불러옵니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비트맵을 화면에 출력하기 전에 파일을 제대로 불러왔는지 여부를 판단해야합니다.&lt;br /&gt;
Load() 함수가 반환하는 타입은 H_REUSLT 입니다.&lt;br /&gt;
반환값은 S_OK(성공) 및 S_FALSE(실패) 값을 가지고 있습니다.&lt;br /&gt;
SUCCEEDED, FAILED 매크로 함수를 이용하여 성공 및 실패 여부 확인을 조건문에 활용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;파일을 불러올 때 기본위치는 cpp 소스파일이 포함된 프로젝트 위치로 지정되어 있습니다.&lt;br /&gt;
상대경로를 사용하여 이미지 폴더에 있는 이미지 파일을 불러오면 됩니다.&lt;/p&gt;

&lt;p&gt;CImage 인스턴스에서 제공되는 BitBlt() 함수를 이용하면&lt;br /&gt;
특정 DC에 CImage 인스턴스가 가지고 있는 이미지를 복사 및 출력할 수 있습니다.&lt;br /&gt;
BitBlt() 함수는 ATL 함수이기에 DC는 HDC 타입을 요구합니다.&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FAILED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;img&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;RAY.bmp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;80&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// bmpImage.Detach();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;간단히 위에 사용 된 BitBlt() 함수를 해석해보면&lt;br /&gt;
   (0,0)에서부터 전체크기만큼 bmpImage 인스턴스가 가지고 있는 이미지 데이터를&lt;br /&gt;
   dc.m_hDC에다가 (80,15)위치에서 (300,300)크기만큼의 이미지를 복사해라 정도가 되겠네요?!&lt;/p&gt;

&lt;h2 id=&quot;f리소스id를-이용해-해당-dc에-이미지를-그려주는-함수&quot;&gt;[F]리소스ID를 이용해 해당 DC에 이미지를 그려주는 함수&lt;/h2&gt;
&lt;figcaption&gt;이 함수는 크기가 작은 이미지를 사용했을 때 빠릅니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DrawFromResourceID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DrawFromResourceID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LoadFromResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AfxGetInstanceHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resourceID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//DrawFromResourceID(dc, 400, 15, 300, 300, IDB_BITMAP1, 0, 0);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;f이미지-파일을-이용해-해당-dc에-이미지를-그려주는-함수&quot;&gt;[F]이미지 파일을 이용해 해당 DC에 이미지를 그려주는 함수&lt;/h2&gt;
&lt;figcaption&gt;이 함수는 크기가 작은 이미지를 사용했을 때 빠릅니다&lt;/figcaption&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DrawFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;BOOL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DrawFromFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CDC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LPCWSTR&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;CImage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FAILED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filePath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FALSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitBlt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_hDC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destWidth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destHeight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;srcY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SRCCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bmpImage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TRUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//DrawFromFile(dc, 80, 15, 300, 300, _T(&quot;.\\res\\img\\RAY.BMP&quot;), 0, 0);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;정리&quot;&gt;정리&lt;/h2&gt;
&lt;p&gt;비트맵 확장명을 가진 파일을 리소스ID를 이용 및 파일을 직접 불러오고&lt;br /&gt;
이미지를 출력하는 방법에 대해 알아보았습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;이미지를 간단히 불러오고 화면에 출력하는데는 CImage 클래스가 적합합니다.&lt;/li&gt;
  &lt;li&gt;LoadFromResource() 함수는 리소스 ID를 이용해 비트맵을 불러옵니다.&lt;/li&gt;
  &lt;li&gt;Load() 함수는 이미지 파일을 이용해 비트맵을 불러옵니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;실습 결과:&lt;br /&gt;
&lt;img src=&quot;/assets/images/CImage/CImageCBitmapBitBlt.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="CImage" /><category term="비트맵" /><category term="Bitmap" /><category term="이미지" /><category term="Image" /><category term="LoadFromResource" /><category term="CImage Load" /><category term="BitBlt" /><summary type="html">[MFC][실습] CImage : 이미지 불러오고 출력하기</summary></entry><entry><title type="html">[MFC] 클래스 계층도</title><link href="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Class-MFC-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5%EB%8F%84/" rel="alternate" type="text/html" title="[MFC] 클래스 계층도" /><published>2020-05-01T00:00:00+09:00</published><updated>2020-05-01T00:00:00+09:00</updated><id>https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Class%20-%20MFC%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EA%B3%84%EC%B8%B5%EB%8F%84</id><content type="html" xml:base="https://tars-c.github.io/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/mfc/Class-MFC-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5%EB%8F%84/">&lt;p&gt;Microsoft에서 제공하는 MFC Class Hierarchy(MFC 클래스 계층도)입니다.&lt;br /&gt;
아래 모든 사진의 출처는 Microsoft가 가지고 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;part1-cobject를-상속받은-클래스-mfc-클래스-계층&quot;&gt;PART1: CObject를 상속받은 클래스 MFC 클래스 계층&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/Hierarchy/mfc_hierarchy_chart1of3.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;part2-ccmdtarget-및-cwnd를-상속받은-클래스-계층&quot;&gt;PART2: CCmdTarget 및 CWnd를 상속받은 클래스 계층&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/Hierarchy/mfc_hierarchy_chart2of3.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;part3-cobject를-상속받지-않은-클래스-계층&quot;&gt;PART3: CObject를 상속받지 않은 클래스 계층&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/Hierarchy/mfc_hierarchy_chart3of3.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고링크: &lt;a href=&quot;https://docs.microsoft.com/ko-kr/cpp/mfc/hierarchy-chart?view=vs-2019&quot; target=&quot;_blank&quot;&gt;MSDN&lt;/a&gt;(사이트 내 PDF 다운로드 지원)&lt;/p&gt;</content><author><name>타스 (TARS-C)</name></author><category term="타스" /><category term="MFC" /><category term="Class" /><category term="Hierarchy" /><summary type="html">[MFC] 클래스 계층도</summary></entry><entry><title type="html">[잡담] MFC 및 WINAPI 이렇게 공부하자</title><link href="https://tars-c.github.io/%EC%9E%A1%EB%8B%B4/MFC%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/" rel="alternate" type="text/html" title="[잡담] MFC 및 WINAPI 이렇게 공부하자" /><published>2020-04-30T00:00:00+09:00</published><updated>2020-04-30T00:00:00+09:00</updated><id>https://tars-c.github.io/%EC%9E%A1%EB%8B%B4/MFC%EB%A5%BC%20%EA%B3%B5%EB%B6%80%ED%95%98%EB%A9%B4%EC%84%9C%20%EB%8A%90%EB%82%80%EC%A0%90</id><content type="html" xml:base="https://tars-c.github.io/%EC%9E%A1%EB%8B%B4/MFC%EB%A5%BC-%EA%B3%B5%EB%B6%80%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80%EC%A0%90/">&lt;p&gt;MFC 및 WINAPI 를 계속 공부하면서 느낀게 하나 있습니다.&lt;br /&gt;
클래스가 제공하는 함수가 나무나 복잡하다는 것입니다.&lt;br /&gt;
함수 이름도 심지어 비슷비슷해서 상당히 복잡해서 익히는데 큰 시간이 소비되는 것 같습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;MFC나 WINAPI는 상당히 코드가 길게 구성되어 있습니다.&lt;br /&gt;
몇몇분들이 이 함수의 매개변수들을 외우려고 하지만&lt;br /&gt;
공부하는 기간동안 이를 다 외워서 코딩하는건 시간낭비일 수도 있습니다.&lt;/p&gt;

&lt;p&gt;전체적으로 작동하는 흐름을 보자면&lt;br /&gt;
수 많은 구조체들이 시스템의 일부를 가르키고 있고 복잡한 구조체를 이용해&lt;br /&gt;
객체를 만들고 함수를 이용하여 시스템을 제어하는 것입니다.&lt;/p&gt;

&lt;p&gt;이를 어느정도 이해를 하는 것이 중요합니다.&lt;/p&gt;

&lt;p&gt;수 많은 클래스가 제공하는 함수를 외울 필요는 없습니다. (외우면 당연히 좋아요)&lt;br /&gt;
하지만 해당 구조체 및 클래스가 어떤 역할을 하는지 이해하는건 필수인 것 같습니다.&lt;br /&gt;
그리고 역할을 이해하게 된다면 제공하는 함수에 대해서도 간접적으로 알 수 있습니다.&lt;br /&gt;
이해를 한다면 나중에 MFC 프로젝트가 필요하거나 WINAPI를 이용한 프로그램을 제작할 때&lt;br /&gt;
복잡한 구조체에 당황하지 않고 프로그래밍이 가능할 것 같습니다. &lt;br /&gt;
클래스 계층도를 이해하는 것 또한 중요합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비슷하면서도 같아보이는 클래스 및 구조체들..
    &lt;ul&gt;
      &lt;li&gt;HBITMAP: (WINAPI BITMAP HANDLE)&lt;/li&gt;
      &lt;li&gt;CBitmap: (GDI BITMAP 객체)&lt;/li&gt;
      &lt;li&gt;Bitmap: (GDI+ BITMAP 객체)&lt;/li&gt;
      &lt;li&gt;BITMAP: (비트맵 정보를 가지는 구조체)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구조체 및 클래스 이름도 상당히 비슷합니다.&lt;br /&gt;
이름들이 거의 한글자씩만 다릅니다. (하아…)&lt;br /&gt;
자주 쓰이는 함수는 어떤 클래스에 속해있는지 알아야하고 함수가 제공하는 매개변수는 msdn이나&lt;br /&gt;
구글링을 통해 큰 흐름을 익히는 것이 중요한 것 같습니다.&lt;/p&gt;

&lt;p&gt;함수 전부 외우거나 이해하는 것보다&lt;br /&gt;
큰 틀(구조체 및 클래스)을 이해하는 것이 중요합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;위 내용을 간략히 정리해보면&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;수 많은 클래스들이 제공하는 함수 및 매개변수를 외우려하지말라&lt;/li&gt;
  &lt;li&gt;클래스와 구조체가 어떤 역할 및 기능을 하는지는 알아두도록 하자
    &lt;ul&gt;
      &lt;li&gt;추가로 함수에서 클래스와 구조체가 필요로 한다면 왜 필요한지 정도는 알아두도록 하자(쓰임세)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 함수의 매개변수는 구글링이나 msdn을 참고하자&lt;/li&gt;
&lt;/ol&gt;</content><author><name>타스 (TARS-C)</name></author><category term="타스" /><category term="MFC" /><category term="공부방법" /><summary type="html">[잡담] MFC 및 WINAPI 이렇게 공부하자</summary></entry></feed>